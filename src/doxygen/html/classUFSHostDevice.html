<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: UFSHostDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>UFSHostDevice Class Reference</h1><!-- doxytag: class="UFSHostDevice" --><!-- doxytag: inherits="DmaDevice" -->
<p>UFS command flow state machine digraph CommandFlow{ node [fontsize=10]; IDLE -&gt; transferHandler [ label=" transfer/task/command request " fontsize=6]; transferHandler -&gt; command [ label=" It is a command " fontsize=6]; command -&gt; IDLE [ label=" Command done, no further action " fontsize=6]; transferHandler -&gt; <a class="el" href="structUFSHostDevice_1_1taskStart.html" title="Task start information.">taskStart</a> [ label=" It is a task " fontsize=6]; <a class="el" href="structUFSHostDevice_1_1taskStart.html" title="Task start information.">taskStart</a> -&gt; finalUTP [ label=" Task handled, now acknowledge (UFS) " fontsize=6]; transferHandler -&gt; <a class="el" href="structUFSHostDevice_1_1transferStart.html" title="Transfer start information.">transferStart</a> [ label=" It is a transfer " fontsize=6]; <a class="el" href="structUFSHostDevice_1_1transferStart.html" title="Transfer start information.">transferStart</a> -&gt; SCSIResume [ label=" Transfer, obtain the specific command " fontsize=6]; SCSIResume -&gt; DiskDataFlowPhase [ label=" Disk data transfer (see other graphs) " fontsize=6]; SCSIResume -&gt; DeviceDataPhase [ label=" Device info transfer (handled in SCSIResume) " fontsize=6]; DiskDataFlowPhase -&gt; transferDone [ label=" Transfer done, acknowledge SCSI command " fontsize=6]; DeviceDataPhase -&gt; transferDone [ label=" Transfer done, acknowledge SCSI command " fontsize=6]; transferDone -&gt; finalUTP [ label=" Transfer handled, now acknowledge (UFS) " fontsize=6]; finalUTP -&gt; readDone [ label=" All handled, clear data structures " fontsize=6]; readDone -&gt; IDLE [ label=" All handled, nothing outstanding " fontsize=6]; readDone -&gt; transferHandler [ label=" All handled, handle next outstanding " fontsize=6]; }.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UFSHostDevice:</div>
<div class="dynsection">
 <div class="center">
  <img src="classUFSHostDevice.gif" usemap="#UFSHostDevice_map" alt=""/>
  <map id="UFSHostDevice_map" name="UFSHostDevice_map">
<area href="classDmaDevice.html" alt="DmaDevice" shape="rect" coords="111,280,212,304"/>
<area href="classPioDevice.html" alt="PioDevice" shape="rect" coords="111,224,212,248"/>
<area href="classMemObject.html" alt="MemObject" shape="rect" coords="111,168,212,192"/>
<area href="classClockedObject.html" alt="ClockedObject" shape="rect" coords="111,112,212,136"/>
<area href="classSimObject.html" alt="SimObject" shape="rect" coords="111,56,212,80"/>
<area href="classEventManager.html" alt="EventManager" shape="rect" coords="0,0,101,24"/>
<area href="classSerializable.html" alt="Serializable" shape="rect" coords="111,0,212,24"/>
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="222,0,323,24"/>
</map>
 </div>
</div>

<p><a href="classUFSHostDevice-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1HCIMem.html">HCIMem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host Controller Interface This is a set of registers that allow the driver to control the transactions to the flash devices.  <a href="structUFSHostDevice_1_1HCIMem.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1LUNInfo.html">LUNInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Logic unit information structure.  <a href="structUFSHostDevice_1_1LUNInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1SCSIReply.html">SCSIReply</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCSI reply structure.  <a href="structUFSHostDevice_1_1SCSIReply.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1SCSIResumeInfo.html">SCSIResumeInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After a SCSI command has been identified, the SCSI resume function will handle it.  <a href="structUFSHostDevice_1_1SCSIResumeInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1taskStart.html">taskStart</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task start information.  <a href="structUFSHostDevice_1_1taskStart.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1transferDoneInfo.html">transferDoneInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transfer completion info.  <a href="structUFSHostDevice_1_1transferDoneInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1transferInfo.html">transferInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Different events, and scenarios require different types of information.  <a href="structUFSHostDevice_1_1transferInfo.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1transferStart.html">transferStart</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer start information.  <a href="structUFSHostDevice_1_1transferStart.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html">UFSHCDSGEntry</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html" title="struct UFSHCDSGEntry - UFSHCI PRD Entry baseAddr: Lower 32bit physical address DW-0...">UFSHCDSGEntry</a> - UFSHCI PRD Entry baseAddr: Lower 32bit physical address DW-0 upperAddr: Upper 32bit physical address DW-1 reserved: Reserved for future use DW-2 size: size of physical segment DW-3  <a href="structUFSHostDevice_1_1UFSHCDSGEntry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UFSHostDeviceStats.html">UFSHostDeviceStats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics.  <a href="structUFSHostDevice_1_1UFSHostDeviceStats.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice_1_1UFSSCSIDevice.html">UFSSCSIDevice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">device layer: This is your Logic unit This layer implements the SCSI functionality of the UFS Device One logic unit controls one or more disk partitions  <a href="classUFSHostDevice_1_1UFSSCSIDevice.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UPIUMessage.html">UPIUMessage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UPIU tranfer message.  <a href="structUFSHostDevice_1_1UPIUMessage.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UTPTransferCMDDesc.html">UTPTransferCMDDesc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structUFSHostDevice_1_1UTPTransferCMDDesc.html" title="struct UTPTransferCMDDesc - UFS Commad Descriptor structure commandUPIU: Command...">UTPTransferCMDDesc</a> - UFS Commad Descriptor structure commandUPIU: Command UPIU Frame address responseUPIU: Response UPIU Frame address PRDTable: Physcial Region Descriptor All lengths as defined by JEDEC220  <a href="structUFSHostDevice_1_1UTPTransferCMDDesc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html">UTPTransferReqDesc</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html" title="struct UTPTransferReqDesc - UTRD structure header: UTRD header DW-0 to DW-3 commandDescBaseAddrLo:...">UTPTransferReqDesc</a> - UTRD structure header: UTRD header DW-0 to DW-3 commandDescBaseAddrLo: UCD base address low DW-4 commandDescBaseAddrHi: UCD base address high DW-5 responseUPIULength: response UPIU length DW-6 responseUPIUOffset: response UPIU offset DW-6 PRDTableLength: Physical region descriptor length DW-7 PRDTableOffset: Physical region descriptor offset DW-7  <a href="structUFSHostDevice_1_1UTPTransferReqDesc.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UTPUPIUHeader.html">UTPUPIUHeader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All the data structures are defined in the UFS standard This standard be found at the JEDEC website free of charge (login required): <a href="http://www.jedec.org/standards-documents/results/jesd220.">http://www.jedec.org/standards-documents/results/jesd220.</a>  <a href="structUFSHostDevice_1_1UTPUPIUHeader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UTPUPIURSP.html">UTPUPIURSP</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structUFSHostDevice_1_1UTPUPIURSP.html" title="struct UTPUPIURSP - Response UPIU structure header: UPIU header DW-0 to DW-2 residualTransferCount:...">UTPUPIURSP</a> - Response UPIU structure header: UPIU header DW-0 to DW-2 residualTransferCount: Residual transfer count DW-3 reserved: Reserved DW-4 to DW-7 senseDataLen: Sense data length DW-8 U16 senseData: Sense data field DW-8 to DW-12  <a href="structUFSHostDevice_1_1UTPUPIURSP.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1UTPUPIUTaskReq.html">UTPUPIUTaskReq</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">struct <a class="el" href="structUFSHostDevice_1_1UTPUPIUTaskReq.html" title="struct UTPUPIUTaskReq - Task request UPIU structure header - UPIU header structure...">UTPUPIUTaskReq</a> - Task request UPIU structure header - UPIU header structure DW0 to DW-2 inputParam1: Input param 1 DW-3 inputParam2: Input param 2 DW-4 inputParam3: Input param 3 DW-5 reserved: Reserver DW-6 to DW-7  <a href="structUFSHostDevice_1_1UTPUPIUTaskReq.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUFSHostDevice_1_1writeToDiskBurst.html">writeToDiskBurst</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disk transfer burst information.  <a href="structUFSHostDevice_1_1writeToDiskBurst.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a7d8b75128b6d66a69c176288712b875c">UFSHostDevice</a> (const UFSHostDeviceParams *p)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the UFS Host device.  <a href="#a7d8b75128b6d66a69c176288712b875c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aa682ec081f300a366492687287dfdfa7">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drain; needed to enable checkpoints.  <a href="#aa682ec081f300a366492687287dfdfa7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aaa4c519c77e200fb2473d6b7263686c7">checkDrain</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checkdrain; needed to enable checkpoints.  <a href="#aaa4c519c77e200fb2473d6b7263686c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a47801b1a2e4a15d1ae9e2b0cce1dc27a">serialize</a> (std::ostream &amp;os)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize; needed to make checkpoints.  <a href="#a47801b1a2e4a15d1ae9e2b0cce1dc27a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a514c422a734637c333e37886f86a528a">unserialize</a> (<a class="el" href="classCheckpoint.html">Checkpoint</a> *cp, const std::string &amp;section)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unserialize; needed to restore from checkpoints.  <a href="#a514c422a734637c333e37886f86a528a"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02d">UFSHCIRegisters</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da481be304461e6af529843cf46d6ac6c6">regControllerCapabilities</a> =  0x00, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daa4591ca59cd55a51c919ad98630c6270">regUFSVersion</a> =  0x08, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da0274c91c048fb2e393f6d43c5b42471e">regControllerDEVID</a> =  0x10, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da8d37a1d56c2a2a51045641b088a45f6c">regControllerPRODID</a> =  0x14, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02dacc38c891fdbd0831db664822f875a626">regInterruptStatus</a> =  0x20, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daaad38c2876bbd9b8baca5f9b4866ba23">regInterruptEnable</a> =  0x24, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da178f79c71e476a2f274a48b8f9a2e36e">regControllerStatus</a> =  0x30, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da57e820f293b4bc643203c6949a8f7575">regControllerEnable</a> =  0x34, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da9bbb45bbc37f4965f20e872b2bae234f">regUICErrorCodePHYAdapterLayer</a> =  0x38, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da7083e21ee94914c921db799a795c0e51">regUICErrorCodeDataLinkLayer</a> =  0x3C, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da2dc3ecf99356465b7089a6cd0ba2f766">regUICErrorCodeNetworkLayer</a> =  0x40, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da98cd53e68c0b47822e4829b598430e90">regUICErrorCodeTransportLayer</a> =  0x44, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da8708fc941ed9fbea752cf6b6b991c512">regUICErrorCodeDME</a> =  0x48, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daddc3f05d8b30d981e4b4d92f3be2ce41">regUTPTransferREQINTAGGControl</a> =  0x4C, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da00633166e61091278363eb7e412d1b6c">regUTPTransferREQListBaseL</a> =  0x50, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daacc929122b4ac86e0cb0d9b4d9e1e91d">regUTPTransferREQListBaseH</a> =  0x54, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da374d60125ac6953255d8dc7f9dd06ff1">regUTPTransferREQDoorbell</a> =  0x58, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da50b10c0d010a09e11fc6336b78c25fbd">regUTPTransferREQListClear</a> =  0x5C, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daf340b5324bfc4aaba7e3ed1187d3c7b3">regUTPTransferREQListRunStop</a> =  0x60, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da951b45e4bd387da3bd97ee1374f8df52">regUTPTaskREQListBaseL</a> =  0x70, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da4daab8a74c75ec995d5e821d920e1ce1">regUTPTaskREQListBaseH</a> =  0x74, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02dab005ad5f156c86741a93ea9b04f1fdf6">regUTPTaskREQDoorbell</a> =  0x78, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da9110cfe62f3186d7eb7b48f50bbc019e">regUTPTaskREQListClear</a> =  0x7C, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da30dbe0e97045aed7628a372451b09614">regUTPTaskREQListRunStop</a> =  0x80, 
<br/>
&nbsp;&nbsp;<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daccd3abb2b875eaf6a394c54d6fe3c667">regUICCommand</a> =  0x90, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02daba51480e9d60c8a4fc06d0cb94351e7e">regUICCommandArg1</a> =  0x94, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da27b1e08bba1f424e31288240572824df">regUICCommandArg2</a> =  0x98, 
<a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02da133c3a5a9a9530c1e4aab668baef9626">regUICCommandArg3</a> =  0x9C
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1list.html">AddrRangeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a444238c3c017d6a0ecb687012cf06db9">getAddrRanges</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classAddress.html">Address</a> range functions.  <a href="#a444238c3c017d6a0ecb687012cf06db9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a83000b816a76017d2c52478529e5bd8a">read</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">register access functions  <a href="#a83000b816a76017d2c52478529e5bd8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a23d2d9d31b5a11d8e13df699bdb8f3a4">write</a> (<a class="el" href="classPacket.html">PacketPtr</a> pkt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UFSHCD write function.  <a href="#a23d2d9d31b5a11d8e13df699bdb8f3a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a375bf9fdfede7b0dbf301dae79ae2328">setValues</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialization function.  <a href="#a375bf9fdfede7b0dbf301dae79ae2328"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a6689fda1fb21622f2f5e547e583ad8f5">requestHandler</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handler functions.  <a href="#a6689fda1fb21622f2f5e547e583ad8f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a244ebbc28d0b9a2595d4eb159743ab2c">commandHandler</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Command handler function.  <a href="#a244ebbc28d0b9a2595d4eb159743ab2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a0a800aaa686c13700089c627fe244591">taskStart</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task Start function.  <a href="#a0a800aaa686c13700089c627fe244591"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#acdeeb5d6e448679537fc1b783cbc81a3">taskHandler</a> (struct <a class="el" href="structUFSHostDevice_1_1UTPUPIUTaskReq.html">UTPUPIUTaskReq</a> *request_in, uint32_t req_pos, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> finaladdress, uint32_t finalsize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Task handler function.  <a href="#acdeeb5d6e448679537fc1b783cbc81a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a807eba6e29725755376b83d17dcea227">transferStart</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer Start function.  <a href="#a807eba6e29725755376b83d17dcea227"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ab99774ea692a4e887e1ca86dfd3e940a">transferHandler</a> (struct <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html">UTPTransferReqDesc</a> *request_in, int req_pos, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> finaladdress, uint32_t finalsize, uint32_t done)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer handler function.  <a href="#ab99774ea692a4e887e1ca86dfd3e940a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a8a08d054940867f114c461a5ed477afb">SCSIStart</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer SCSI function.  <a href="#a8a08d054940867f114c461a5ed477afb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#abbd53b76896313d34e8c9ed20b5fc79c">SCSIResume</a> (uint32_t lun_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the scsi handling function in the apropriate Logic unit, prepares the right data transfer scheme and kicks it off.  <a href="#abbd53b76896313d34e8c9ed20b5fc79c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a32d78ae4c6ef3dbfe3ac26d55692a6cc">LUNSignal</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU callback function to indicate that the action has completed.  <a href="#a32d78ae4c6ef3dbfe3ac26d55692a6cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ab7284900b111b9990ac2f494a19413c7">transferDone</a> (<a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> responseStartAddr, uint32_t req_pos, struct <a class="el" href="structUFSHostDevice_1_1UTPUPIURSP.html">UTPUPIURSP</a> request_out, uint32_t size, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> address, uint8_t *destination, bool finished, uint32_t lun_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">transfer done, the beginning of the final stage of the transfer.  <a href="#ab7284900b111b9990ac2f494a19413c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a9de6e5d410663f3af1fdef53b55997f8">finalUTP</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">final UTP, sends the last acknowledge data structure to the system; prepares the clean up functions.  <a href="#a9de6e5d410663f3af1fdef53b55997f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a3570e43eb14a85c8e7840afd27eb9845">clearInterrupt</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interrupt control functions.  <a href="#a3570e43eb14a85c8e7840afd27eb9845"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a99c0eda6ffc1939b05cb5e4492ac117b">generateInterrupt</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set interrupt and sort out the doorbell register.  <a href="#a99c0eda6ffc1939b05cb5e4492ac117b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a8c9877d376633c69e4188d0db080a589">writeDevice</a> (<a class="el" href="classEvent.html">Event</a> *additional_action, bool toDisk, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> start, int size, uint8_t *destination, uint64_t SCSIDiskOffset, uint32_t lun_id)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA transfer functions These allow the host to push/pull the data to the memory The provided event indicates what the next phase it that will handle the obtained data, or what the follow up action is once the data has been pushed to the memory.  <a href="#a8c9877d376633c69e4188d0db080a589"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ad901dabdffb2047844f124ee5ce1328d">readDevice</a> (bool lastTransfer, <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> SCSIStart, uint32_t SCSISize, uint8_t *SCSIDestination, bool no_cache, <a class="el" href="classEvent.html">Event</a> *additional_action)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dma transaction function: read device.  <a href="#ad901dabdffb2047844f124ee5ce1328d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a43c98267d32cb45293de172eda4f04f7">manageWriteTransfer</a> (uint8_t LUN, uint64_t offset, uint32_t sg_table_length, struct <a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html">UFSHCDSGEntry</a> *sglist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disk transfer management functions these set up the queues, and initiated them, leading to the data transaction timing model based on the scatter gather list constructed in SCSIresume.  <a href="#a43c98267d32cb45293de172eda4f04f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aebef3ab77126553cee4fb576cc989e31">manageReadTransfer</a> (uint32_t size, uint32_t LUN, uint64_t offset, uint32_t sg_table_length, struct <a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html">UFSHCDSGEntry</a> *sglist)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manage read transfer.  <a href="#aebef3ab77126553cee4fb576cc989e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a716c4c8aa36cdc5b7057bba546e1f0bb">readDone</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read done Started at the end of a transaction after the last read action.  <a href="#a716c4c8aa36cdc5b7057bba546e1f0bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a8ae430d8a91a02c9c9029e214da46a3a">writeDone</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write done After a DMA write with data intended for the disk, this function is called.  <a href="#a8ae430d8a91a02c9c9029e214da46a3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ac4324a5e5064eca02bdbbdb99c830f73">readCallback</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read callback Call back function for the logic units to indicate the completion of a read action.  <a href="#ac4324a5e5064eca02bdbbdb99c830f73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a83f5818b278086314c754455d514e03f">readGarbage</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read garbage A read from disk data structure can vary in size and is therefor allocated on creation.  <a href="#a83f5818b278086314c754455d514e03f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ab93a44d559afdc243605292580c49010">regStats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">register statistics  <a href="#ab93a44d559afdc243605292580c49010"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#affa8ce012dc48726416c4cd7cdf1180d">pioAddr</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host controller information.  <a href="#affa8ce012dc48726416c4cd7cdf1180d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a125c59dd539330089aedb2c4003089ff">pioSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a643c0a3668c1597e33b721ebd3d6fded">pioDelay</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aaffec0570461ca146db679667d44876f">intNum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseGic.html">BaseGic</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a987ab112c90c4c3eb5d1ccbee82c864a">gic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a5bca87883eaaf14f7e657d2b912cd20d">lunAvail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#acf02882943451c5bf52ba1a261e9f217">UFSSlots</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUFSHostDevice_1_1HCIMem.html">HCIMem</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a42bb5c0dfc5f68271dfa9341da2f90c5">UFSHCIMem</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Host controller memory.  <a href="#a42bb5c0dfc5f68271dfa9341da2f90c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a0c2bb7b9016db0c72c2c1640c9769966">readPendingNum</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track number of DMA transactions in progress.  <a href="#a0c2bb7b9016db0c72c2c1640c9769966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a1ef599ebb3035b24426fd3a88e41cb5d">writePendingNum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a16f2e11f7a738325c2670d4436a741b7">activeDoorbells</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Statistics helper variables Active doorbells indicates how many doorbells are in teh process of being handled.  <a href="#a16f2e11f7a738325c2670d4436a741b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a9ad1d3e7f1698d45335b6a5ec7128e04">pendingDoorbells</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ae9df73da0e26359e8b0f11d94b79a1c8">countInt</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">interrupt verification This keeps track of the number of interrupts generated.  <a href="#ae9df73da0e26359e8b0f11d94b79a1c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a9fdd54e78b6c6797f78e869fe67b1362">transferTrack</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track the transfer This is allows the driver to "group" certain transfers together by using a tag in the UPIU.  <a href="#a9fdd54e78b6c6797f78e869fe67b1362"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a2ad1bf7f00d4e944c7ca004b5ddb2c81">taskCommandTrack</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ac6cef6d6deeb2b63d75b9af0a7530c62">transactionStart</a> [32]</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for latency stats These variables keep track of the latency for every doorbell.  <a href="#ac6cef6d6deeb2b63d75b9af0a7530c62"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#af08a84cb2546369cd56722161985d383">idlePhaseStart</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aaeca5f87415474b86c6c3690e68f9e88">drainManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">drain manager Needed to be able to implement checkpoint functionality  <a href="#aaeca5f87415474b86c6c3690e68f9e88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt; <a class="el" href="classUFSHostDevice_1_1UFSSCSIDevice.html">UFSSCSIDevice</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#af41e655708399351b96c0d65d77adb04">UFSDevice</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">logic units connected to the UFS Host device Note again that the "device" as such is represented by one or multiple logic units.  <a href="#af41e655708399351b96c0d65d77adb04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structUFSHostDevice_1_1SCSIReply.html">SCSIReply</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a980f9a20b4cfcc5ac36b10dc8a2dafa9">request_out_datain</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCSI reply structure, used for direct answering.  <a href="#a980f9a20b4cfcc5ac36b10dc8a2dafa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structUFSHostDevice_1_1SCSIResumeInfo.html">SCSIResumeInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a9ddaf7164922015fc943e5554fc7ef04">SCSIInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SCSI resume info information structure for SCSI resume.  <a href="#a9ddaf7164922015fc943e5554fc7ef04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <a class="el" href="structUFSHostDevice_1_1transferStart.html">transferStart</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#adaa5cb5f2698e8d845d41615dc0ea074">transferEnd</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To finish the transaction one needs information about the original message.  <a href="#adaa5cb5f2698e8d845d41615dc0ea074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <a class="el" href="structUFSHostDevice_1_1taskStart.html">taskStart</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a3a1417b4e9c1813ae13da072112d05e0">taskInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When a task/transfer is started it needs information about the task/transfer it is about to perform.  <a href="#a3a1417b4e9c1813ae13da072112d05e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <a class="el" href="structUFSHostDevice_1_1transferStart.html">transferStart</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ac72374443f2d7b5088387317d84f3be7">transferStartInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <br class="typebreak"/>
<a class="el" href="structUFSHostDevice_1_1writeToDiskBurst.html">writeToDiskBurst</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ac517d135aba91b1c6afb06a9f298936f">dmaWriteInfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information to get a DMA transaction.  <a href="#ac517d135aba91b1c6afb06a9f298936f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <a class="el" href="structUFSHostDevice_1_1transferInfo.html">transferInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a170d0b32c309d44f0769def6a5d9ae41">SSDWriteinfo</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information from DMA transaction to disk.  <a href="#a170d0b32c309d44f0769def6a5d9ae41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <a class="el" href="structUFSHostDevice_1_1transferInfo.html">transferInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a0c157aeb57ad361cda7a370559ab48cd">SSDReadPending</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information from the Disk, waiting to be pushed to the DMA.  <a href="#a0c157aeb57ad361cda7a370559ab48cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; struct <br class="typebreak"/>
<a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html">UTPTransferReqDesc</a> * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ad79d4e27ba055c7dee98c3faff190ac3">garbage</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">garbage queue, ensure clearing of the allocated memory  <a href="#ad79d4e27ba055c7dee98c3faff190ac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structUFSHostDevice_1_1UFSHostDeviceStats.html">UFSHostDeviceStats</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#afc5c67585a481a5fdc9f9ccdb110ae5a">stats</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RequestHandler stats.  <a href="#afc5c67585a481a5fdc9f9ccdb110ae5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classEventWrapper.html">EventWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;UFSHostDevice::readDone &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ac08ac50075113848011226ba98121ddb">readDoneEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Transfer flow events Basically these events form two queues, one from memory to UFS device (DMA) and one from device to flash (SSD).  <a href="#ac08ac50075113848011226ba98121ddb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classEventWrapper.html">EventWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;UFSHostDevice::writeDone &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a7b9c9749123042c563cd1d6fde9074e7">writeDoneEvent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCallback.html">Callback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a0e5c2208e40f9b90cb48fe8a73328abb">transferDoneCallback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callbacks for the logic units.  <a href="#a0e5c2208e40f9b90cb48fe8a73328abb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCallback.html">Callback</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#ab90be2d6333101131603513849f1d8aa">memReadCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;UFSHostDevice::SCSIStart &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#aadf97748a0d65f612d66caa66694653a">SCSIResumeEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The events that control the functionality.  <a href="#aadf97748a0d65f612d66caa66694653a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;UFSHostDevice::finalUTP &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a8cf81d83001c40ab22899e26a798856a">UTPEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the moment where we can send the last frame.  <a href="#a8cf81d83001c40ab22899e26a798856a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classEventWrapper.html">EventWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;UFSHostDevice::readGarbage &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a623d595cec1e11d9edaa207ba2d7471f">readGarbageEventQueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classEvent.html">Event</a> after a read to clean up the UTP data structures.  <a href="#a623d595cec1e11d9edaa207ba2d7471f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classEventWrapper.html">EventWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;<a class="el" href="structUFSHostDevice_1_1taskStart.html">UFSHostDevice::taskStart</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a43b88841e2b65caf68dc581c4219e308">taskEventQueue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiple tasks transfers can be scheduled at once for the device, the only thing we know for sure about them is that they will happen in a first come first serve order; hence we need to queue.  <a href="#a43b88841e2b65caf68dc581c4219e308"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; <a class="el" href="classEventWrapper.html">EventWrapper</a><br class="typebreak"/>
&lt; <a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>,&amp;<a class="el" href="structUFSHostDevice_1_1transferStart.html">UFSHostDevice::transferStart</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a906cf4e1a2bd3226f9dc2ab047935cde">transferEventQueue</a></td></tr>
<tr><td colspan="2"><h2>Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a27697d97aa3d4781af6668f558d98cd7">UTPTransferREQCOMPL</a> = 0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bits of interest within UFS data packages.  <a href="#a27697d97aa3d4781af6668f558d98cd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#acb934c31fb64417a09fc26151b738600">UTPTaskREQCOMPL</a> = 0x200</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a576c3aae41360d989456d8f9cb5ed3f1">UICCommandCOMPL</a> = 0x400</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUFSHostDevice.html#a98894aa7d578f6d0c2535f95decbd626">UICCommandReady</a> = 0x08</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>UFS command flow state machine digraph CommandFlow{ node [fontsize=10]; IDLE -&gt; transferHandler [ label=" transfer/task/command request " fontsize=6]; transferHandler -&gt; command [ label=" It is a command " fontsize=6]; command -&gt; IDLE [ label=" Command done, no further action " fontsize=6]; transferHandler -&gt; <a class="el" href="structUFSHostDevice_1_1taskStart.html" title="Task start information.">taskStart</a> [ label=" It is a task " fontsize=6]; <a class="el" href="structUFSHostDevice_1_1taskStart.html" title="Task start information.">taskStart</a> -&gt; finalUTP [ label=" Task handled, now acknowledge (UFS) " fontsize=6]; transferHandler -&gt; <a class="el" href="structUFSHostDevice_1_1transferStart.html" title="Transfer start information.">transferStart</a> [ label=" It is a transfer " fontsize=6]; <a class="el" href="structUFSHostDevice_1_1transferStart.html" title="Transfer start information.">transferStart</a> -&gt; SCSIResume [ label=" Transfer, obtain the specific command " fontsize=6]; SCSIResume -&gt; DiskDataFlowPhase [ label=" Disk data transfer (see other graphs) " fontsize=6]; SCSIResume -&gt; DeviceDataPhase [ label=" Device info transfer (handled in SCSIResume) " fontsize=6]; DiskDataFlowPhase -&gt; transferDone [ label=" Transfer done, acknowledge SCSI command " fontsize=6]; DeviceDataPhase -&gt; transferDone [ label=" Transfer done, acknowledge SCSI command " fontsize=6]; transferDone -&gt; finalUTP [ label=" Transfer handled, now acknowledge (UFS) " fontsize=6]; finalUTP -&gt; readDone [ label=" All handled, clear data structures " fontsize=6]; readDone -&gt; IDLE [ label=" All handled, nothing outstanding " fontsize=6]; readDone -&gt; transferHandler [ label=" All handled, handle next outstanding " fontsize=6]; }. </p>
<p>UFS read transaction flow state machine digraph readFlow{ node [fontsize=10]; getScatterGather -&gt; commitReadFromDisk [ label=" Put the information about the data transfer to the disk " fontsize=6]; commitReadFromDisk -&gt; waitForReads [ label=" Push the reads to the flashmodel and wait for callbacks " fontsize=6]; waitForReads -&gt; pushToDMA [ label=" Push to the DMA and wait for them to finish " fontsize=6]; pushToDMA -&gt; waitForReads [ label=" Wait for the next disk event " fontsize=6]; pushToDMA -&gt; waitForDMA [ label=" Wait for the last DMA transfer to finish " fontsize=6]; waitForDMA -&gt; finishTransfer [ label=" Continue with the command flow " fontsize=6]; } UFS write transaction flow state machine digraph WriteFlow{ node [fontsize=10]; getScatterGather -&gt; getFromDMA [ label=" Put the transfer information to the DMA " fontsize=6]; getFromDMA -&gt; waitForDMA [ label=" Wait for dma actions to arrive " fontsize=6]; waitForDMA -&gt; pushToDisk [ label=" Push arrived DMA to disk " fontsize=6]; pushToDisk -&gt; waitForDMA [ label=" Wait for next DMA action " fontsize=6]; pushToDisk -&gt; waitForDisk [ label=" All DMA actions are done, wait for disk " fontsize=6]; waitForDisk -&gt; finishTransfer [ label=" All transactions are done , continue the command flow " fontsize=6]; } Host controller layer: This is your Host controller This layer handles the UFS functionality. It tracks all the different transaction stages and uses the device layer and the flash layer to determine the transaction flow. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l00170">170</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02d"></a><!-- doxytag: member="UFSHostDevice::UFSHCIRegisters" ref="ad2247ca7dee36f882e3d2a512537f02d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classUFSHostDevice.html#ad2247ca7dee36f882e3d2a512537f02d">UFSHostDevice::UFSHCIRegisters</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da481be304461e6af529843cf46d6ac6c6"></a><!-- doxytag: member="regControllerCapabilities" ref="ad2247ca7dee36f882e3d2a512537f02da481be304461e6af529843cf46d6ac6c6" args="" -->regControllerCapabilities</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daa4591ca59cd55a51c919ad98630c6270"></a><!-- doxytag: member="regUFSVersion" ref="ad2247ca7dee36f882e3d2a512537f02daa4591ca59cd55a51c919ad98630c6270" args="" -->regUFSVersion</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da0274c91c048fb2e393f6d43c5b42471e"></a><!-- doxytag: member="regControllerDEVID" ref="ad2247ca7dee36f882e3d2a512537f02da0274c91c048fb2e393f6d43c5b42471e" args="" -->regControllerDEVID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da8d37a1d56c2a2a51045641b088a45f6c"></a><!-- doxytag: member="regControllerPRODID" ref="ad2247ca7dee36f882e3d2a512537f02da8d37a1d56c2a2a51045641b088a45f6c" args="" -->regControllerPRODID</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02dacc38c891fdbd0831db664822f875a626"></a><!-- doxytag: member="regInterruptStatus" ref="ad2247ca7dee36f882e3d2a512537f02dacc38c891fdbd0831db664822f875a626" args="" -->regInterruptStatus</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daaad38c2876bbd9b8baca5f9b4866ba23"></a><!-- doxytag: member="regInterruptEnable" ref="ad2247ca7dee36f882e3d2a512537f02daaad38c2876bbd9b8baca5f9b4866ba23" args="" -->regInterruptEnable</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da178f79c71e476a2f274a48b8f9a2e36e"></a><!-- doxytag: member="regControllerStatus" ref="ad2247ca7dee36f882e3d2a512537f02da178f79c71e476a2f274a48b8f9a2e36e" args="" -->regControllerStatus</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da57e820f293b4bc643203c6949a8f7575"></a><!-- doxytag: member="regControllerEnable" ref="ad2247ca7dee36f882e3d2a512537f02da57e820f293b4bc643203c6949a8f7575" args="" -->regControllerEnable</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da9bbb45bbc37f4965f20e872b2bae234f"></a><!-- doxytag: member="regUICErrorCodePHYAdapterLayer" ref="ad2247ca7dee36f882e3d2a512537f02da9bbb45bbc37f4965f20e872b2bae234f" args="" -->regUICErrorCodePHYAdapterLayer</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da7083e21ee94914c921db799a795c0e51"></a><!-- doxytag: member="regUICErrorCodeDataLinkLayer" ref="ad2247ca7dee36f882e3d2a512537f02da7083e21ee94914c921db799a795c0e51" args="" -->regUICErrorCodeDataLinkLayer</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da2dc3ecf99356465b7089a6cd0ba2f766"></a><!-- doxytag: member="regUICErrorCodeNetworkLayer" ref="ad2247ca7dee36f882e3d2a512537f02da2dc3ecf99356465b7089a6cd0ba2f766" args="" -->regUICErrorCodeNetworkLayer</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da98cd53e68c0b47822e4829b598430e90"></a><!-- doxytag: member="regUICErrorCodeTransportLayer" ref="ad2247ca7dee36f882e3d2a512537f02da98cd53e68c0b47822e4829b598430e90" args="" -->regUICErrorCodeTransportLayer</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da8708fc941ed9fbea752cf6b6b991c512"></a><!-- doxytag: member="regUICErrorCodeDME" ref="ad2247ca7dee36f882e3d2a512537f02da8708fc941ed9fbea752cf6b6b991c512" args="" -->regUICErrorCodeDME</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daddc3f05d8b30d981e4b4d92f3be2ce41"></a><!-- doxytag: member="regUTPTransferREQINTAGGControl" ref="ad2247ca7dee36f882e3d2a512537f02daddc3f05d8b30d981e4b4d92f3be2ce41" args="" -->regUTPTransferREQINTAGGControl</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da00633166e61091278363eb7e412d1b6c"></a><!-- doxytag: member="regUTPTransferREQListBaseL" ref="ad2247ca7dee36f882e3d2a512537f02da00633166e61091278363eb7e412d1b6c" args="" -->regUTPTransferREQListBaseL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daacc929122b4ac86e0cb0d9b4d9e1e91d"></a><!-- doxytag: member="regUTPTransferREQListBaseH" ref="ad2247ca7dee36f882e3d2a512537f02daacc929122b4ac86e0cb0d9b4d9e1e91d" args="" -->regUTPTransferREQListBaseH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da374d60125ac6953255d8dc7f9dd06ff1"></a><!-- doxytag: member="regUTPTransferREQDoorbell" ref="ad2247ca7dee36f882e3d2a512537f02da374d60125ac6953255d8dc7f9dd06ff1" args="" -->regUTPTransferREQDoorbell</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da50b10c0d010a09e11fc6336b78c25fbd"></a><!-- doxytag: member="regUTPTransferREQListClear" ref="ad2247ca7dee36f882e3d2a512537f02da50b10c0d010a09e11fc6336b78c25fbd" args="" -->regUTPTransferREQListClear</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daf340b5324bfc4aaba7e3ed1187d3c7b3"></a><!-- doxytag: member="regUTPTransferREQListRunStop" ref="ad2247ca7dee36f882e3d2a512537f02daf340b5324bfc4aaba7e3ed1187d3c7b3" args="" -->regUTPTransferREQListRunStop</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da951b45e4bd387da3bd97ee1374f8df52"></a><!-- doxytag: member="regUTPTaskREQListBaseL" ref="ad2247ca7dee36f882e3d2a512537f02da951b45e4bd387da3bd97ee1374f8df52" args="" -->regUTPTaskREQListBaseL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da4daab8a74c75ec995d5e821d920e1ce1"></a><!-- doxytag: member="regUTPTaskREQListBaseH" ref="ad2247ca7dee36f882e3d2a512537f02da4daab8a74c75ec995d5e821d920e1ce1" args="" -->regUTPTaskREQListBaseH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02dab005ad5f156c86741a93ea9b04f1fdf6"></a><!-- doxytag: member="regUTPTaskREQDoorbell" ref="ad2247ca7dee36f882e3d2a512537f02dab005ad5f156c86741a93ea9b04f1fdf6" args="" -->regUTPTaskREQDoorbell</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da9110cfe62f3186d7eb7b48f50bbc019e"></a><!-- doxytag: member="regUTPTaskREQListClear" ref="ad2247ca7dee36f882e3d2a512537f02da9110cfe62f3186d7eb7b48f50bbc019e" args="" -->regUTPTaskREQListClear</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da30dbe0e97045aed7628a372451b09614"></a><!-- doxytag: member="regUTPTaskREQListRunStop" ref="ad2247ca7dee36f882e3d2a512537f02da30dbe0e97045aed7628a372451b09614" args="" -->regUTPTaskREQListRunStop</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daccd3abb2b875eaf6a394c54d6fe3c667"></a><!-- doxytag: member="regUICCommand" ref="ad2247ca7dee36f882e3d2a512537f02daccd3abb2b875eaf6a394c54d6fe3c667" args="" -->regUICCommand</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02daba51480e9d60c8a4fc06d0cb94351e7e"></a><!-- doxytag: member="regUICCommandArg1" ref="ad2247ca7dee36f882e3d2a512537f02daba51480e9d60c8a4fc06d0cb94351e7e" args="" -->regUICCommandArg1</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da27b1e08bba1f424e31288240572824df"></a><!-- doxytag: member="regUICCommandArg2" ref="ad2247ca7dee36f882e3d2a512537f02da27b1e08bba1f424e31288240572824df" args="" -->regUICCommandArg2</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad2247ca7dee36f882e3d2a512537f02da133c3a5a9a9530c1e4aab668baef9626"></a><!-- doxytag: member="regUICCommandArg3" ref="ad2247ca7dee36f882e3d2a512537f02da133c3a5a9a9530c1e4aab668baef9626" args="" -->regUICCommandArg3</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01198">1198</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7d8b75128b6d66a69c176288712b875c"></a><!-- doxytag: member="UFSHostDevice::UFSHostDevice" ref="a7d8b75128b6d66a69c176288712b875c" args="(const UFSHostDeviceParams *p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UFSHostDevice::UFSHostDevice </td>
          <td>(</td>
          <td class="paramtype">const UFSHostDeviceParams *&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for the UFS Host device. </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l00719">719</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="base_2misc_8hh_source.html#l00113">fatal</a>, <a class="el" href="ufs__device_8hh_source.html#l01001">lunAvail</a>, <a class="el" href="ufs__device_8cc_source.html#l01671">LUNSignal()</a>, <a class="el" href="ufs__device_8hh_source.html#l01150">memReadCallback</a>, <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, <a class="el" href="ufs__device_8cc_source.html#l00888">setValues()</a>, <a class="el" href="ufs__device_8hh_source.html#l01149">transferDoneCallback</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8hh_source.html#l01002">UFSSlots</a>, and <a class="el" href="base_2misc_8hh_source.html#l00207">warn</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aaa4c519c77e200fb2473d6b7263686c7"></a><!-- doxytag: member="UFSHostDevice::checkDrain" ref="aaa4c519c77e200fb2473d6b7263686c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::checkDrain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checkdrain; needed to enable checkpoints. </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02349">2349</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01024">activeDoorbells</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01060">drainManager</a>, <a class="el" href="drain_8hh_source.html#l00086">DrainManager::signalDrainDone()</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

</div>
</div>
<a class="anchor" id="a3570e43eb14a85c8e7840afd27eb9845"></a><!-- doxytag: member="UFSHostDevice::clearInterrupt" ref="a3570e43eb14a85c8e7840afd27eb9845" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::clearInterrupt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interrupt control functions. </p>
<p>Clear interrupt. </p>

<p><p>end of a transaction </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01837">1837</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="classBaseGic.html#a328f3e426fd8f8bb0a96341eee65d54c">BaseGic::clearInt()</a>, <a class="el" href="ufs__device_8hh_source.html#l01034">countInt</a>, <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01000">gic</a>, <a class="el" href="ufs__device_8hh_source.html#l01053">idlePhaseStart</a>, <a class="el" href="ufs__device_8hh_source.html#l00999">intNum</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00928">read()</a>.</p>

</div>
</div>
<a class="anchor" id="a244ebbc28d0b9a2595d4eb159743ab2c"></a><!-- doxytag: member="UFSHostDevice::commandHandler" ref="a244ebbc28d0b9a2595d4eb159743ab2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::commandHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Command handler function. </p>
<p>Handles the commands that are given.</p>
<p>Handles the command send to the Host controller</p>
<p>At this point in time, not many commands have been implemented in the driver. </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01381">1381</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00238">UFSHostDevice::HCIMem::CMDUICCMDR</a>, <a class="el" href="ufs__device_8hh_source.html#l00203">UFSHostDevice::HCIMem::ORHostControllerStatus</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aa682ec081f300a366492687287dfdfa7"></a><!-- doxytag: member="UFSHostDevice::drain" ref="aa682ec081f300a366492687287dfdfa7" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int UFSHostDevice::drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drain; needed to enable checkpoints. </p>

<p>Reimplemented from <a class="el" href="classDmaDevice.html#a4a7db14b0ca2251d3bcf65e3f858990e">DmaDevice</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02320">2320</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="dma__device_8hh_source.html#l00156">DmaDevice::dmaPort</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="dma__device_8cc_source.html#l00140">DmaPort::drain()</a>, <a class="el" href="qport_8hh_source.html#l00099">QueuedSlavePort::drain()</a>, <a class="el" href="drain_8hh_source.html#l00165">Drainable::Drained</a>, <a class="el" href="drain_8hh_source.html#l00164">Drainable::Draining</a>, <a class="el" href="ufs__device_8hh_source.html#l01060">drainManager</a>, <a class="el" href="io__device_8hh_source.html#l00091">PioDevice::pioPort</a>, <a class="el" href="drain_8hh_source.html#l00231">Drainable::setDrainState()</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

</div>
</div>
<a class="anchor" id="a9de6e5d410663f3af1fdef53b55997f8"></a><!-- doxytag: member="UFSHostDevice::finalUTP" ref="a9de6e5d410663f3af1fdef53b55997f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::finalUTP </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>final UTP, sends the last acknowledge data structure to the system; prepares the clean up functions. </p>
<p>finalUTP.</p>
<p>Second part of the transfer done event. this sends the final response: the UTP response. After this transaction the doorbell shall be cleared, and the interupt shall be set. </p>

<p><p>stats</p>
<p>Last message that will be transfered</p>
<p>clean and ensure that the tracker is updated</p>
<p>stats</p>
<p>This is the moment that the device is available again </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01742">1742</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01024">activeDoorbells</a>, <a class="el" href="ufs__device_8hh_source.html#l00521">UFSHostDevice::UFSHostDeviceStats::averageDoorbell</a>, <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01123">garbage</a>, <a class="el" href="ufs__device_8hh_source.html#l00520">UFSHostDevice::UFSHostDeviceStats::maxDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l01025">pendingDoorbells</a>, <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, <a class="el" href="statistics_8hh_source.html#l01852">Stats::DistBase&lt; Derived, Stor &gt;::sample()</a>, <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00524">UFSHostDevice::UFSHostDeviceStats::transactionLatency</a>, <a class="el" href="ufs__device_8hh_source.html#l01052">transactionStart</a>, <a class="el" href="ufs__device_8hh_source.html#l01091">transferEnd</a>, <a class="el" href="ufs__device_8hh_source.html#l01183">transferEventQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01044">transferTrack</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="statistics_8hh_source.html#l00673">Stats::ScalarBase&lt; Derived, Stor &gt;::value()</a>.</p>

</div>
</div>
<a class="anchor" id="a99c0eda6ffc1939b05cb5e4492ac117b"></a><!-- doxytag: member="UFSHostDevice::generateInterrupt" ref="a99c0eda6ffc1939b05cb5e4492ac117b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::generateInterrupt </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set interrupt and sort out the doorbell register. </p>

<p><p>just to keep track of the transactions</p>
<p>step5 clear doorbell</p>
<p>step6 raise interrupt </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01816">1816</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01034">countInt</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01000">gic</a>, <a class="el" href="ufs__device_8hh_source.html#l00999">intNum</a>, <a class="el" href="ufs__device_8hh_source.html#l01025">pendingDoorbells</a>, <a class="el" href="classBaseGic.html#a9f3e3273b9bb7b3b004d8702542f630e">BaseGic::sendInt()</a>, <a class="el" href="ufs__device_8hh_source.html#l01044">transferTrack</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a444238c3c017d6a0ecb687012cf06db9"></a><!-- doxytag: member="UFSHostDevice::getAddrRanges" ref="a444238c3c017d6a0ecb687012cf06db9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1list.html">AddrRangeList</a> UFSHostDevice::getAddrRanges </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classAddress.html">Address</a> range functions. </p>
<p>Determine address ranges. </p>

<p>Implements <a class="el" href="classPioDevice.html#a6715fdf3071c798a806fdca5c84895e4">PioDevice</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l00915">915</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00996">pioAddr</a>, <a class="el" href="ufs__device_8hh_source.html#l00997">pioSize</a>, and <a class="el" href="addr__range_8hh_source.html#l00404">RangeSize()</a>.</p>

</div>
</div>
<a class="anchor" id="a32d78ae4c6ef3dbfe3ac26d55692a6cc"></a><!-- doxytag: member="UFSHostDevice::LUNSignal" ref="a32d78ae4c6ef3dbfe3ac26d55692a6cc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::LUNSignal </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>LU callback function to indicate that the action has completed. </p>
<p>Find finished transfer.</p>
<p><a class="el" href="classCallback.html" title="Generic callback class.">Callback</a> function. One of the LUNs is done with the disk transfer and reports back to the controller. This function finds out who it was, and calls transferDone. </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01671">1671</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="ufs__device_8hh_source.html#l01001">lunAvail</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>, and <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="aebef3ab77126553cee4fb576cc989e31"></a><!-- doxytag: member="UFSHostDevice::manageReadTransfer" ref="aebef3ab77126553cee4fb576cc989e31" args="(uint32_t size, uint32_t LUN, uint64_t offset, uint32_t sg_table_length, struct UFSHCDSGEntry *sglist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::manageReadTransfer </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>LUN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>sg_table_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html">UFSHCDSGEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>sglist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Manage read transfer. </p>
<p>Manages correct transfer flow and makes sure that the queues are filled on time </p>

<p><p>Break-up the transactions into actions defined by the scatter gather list.</p>
<p>The disk image is read here; but the action is simultated later You can see this as the preparation stage, whereas later is the simulation phase.</p>
<p>stats</p>
<p>stats </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02110">2110</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00515">UFSHostDevice::UFSHostDeviceStats::averageReadSSDQueue</a>, <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="ufs__device_8hh_source.html#l00498">UFSHostDevice::UFSHostDeviceStats::currentReadSSDQueue</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00426">UFSHostDevice::transferInfo::filePointer</a>, <a class="el" href="ufs__device_8hh_source.html#l00427">UFSHostDevice::transferInfo::lunID</a>, <a class="el" href="ufs__device_8hh_source.html#l00425">UFSHostDevice::transferInfo::offset</a>, <a class="el" href="ufs__device_8hh_source.html#l00306">UFSHostDevice::UFSHCDSGEntry::size</a>, <a class="el" href="ufs__device_8hh_source.html#l00424">UFSHostDevice::transferInfo::size</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00502">UFSHostDevice::UFSHostDeviceStats::totalReadSSD</a>, <a class="el" href="ufs__device_8hh_source.html#l00506">UFSHostDevice::UFSHostDeviceStats::totalReadUFSTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, and <a class="el" href="ufs__device_8hh_source.html#l00304">UFSHostDevice::UFSHCDSGEntry::upperAddr</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>.</p>

</div>
</div>
<a class="anchor" id="a43c98267d32cb45293de172eda4f04f7"></a><!-- doxytag: member="UFSHostDevice::manageWriteTransfer" ref="a43c98267d32cb45293de172eda4f04f7" args="(uint8_t LUN, uint64_t offset, uint32_t sg_table_length, struct UFSHCDSGEntry *sglist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::manageWriteTransfer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>LUN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>sg_table_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structUFSHostDevice_1_1UFSHCDSGEntry.html">UFSHCDSGEntry</a> *&nbsp;</td>
          <td class="paramname"> <em>sglist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disk transfer management functions these set up the queues, and initiated them, leading to the data transaction timing model based on the scatter gather list constructed in SCSIresume. </p>
<p>Manage write transfer.</p>
<p>Manages correct transfer flow and makes sure that the queues are filled on time </p>

<p><p>Break-up the transactions into actions defined by the scatter gather list.</p>
<p>If the queue is empty, the transaction should be initiated</p>
<p>stats</p>
<p>stats </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01923">1923</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="ufs__device_8hh_source.html#l01108">dmaWriteInfo</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00489">UFSHostDevice::writeToDiskBurst::LUN</a>, <a class="el" href="ufs__device_8hh_source.html#l00487">UFSHostDevice::writeToDiskBurst::SCSIDiskOffset</a>, <a class="el" href="ufs__device_8hh_source.html#l00488">UFSHostDevice::writeToDiskBurst::size</a>, <a class="el" href="ufs__device_8hh_source.html#l00306">UFSHostDevice::UFSHCDSGEntry::size</a>, <a class="el" href="ufs__device_8hh_source.html#l00486">UFSHostDevice::writeToDiskBurst::start</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00507">UFSHostDevice::UFSHostDeviceStats::totalWriteUFSTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l00503">UFSHostDevice::UFSHostDeviceStats::totalWrittenSSD</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8hh_source.html#l00304">UFSHostDevice::UFSHCDSGEntry::upperAddr</a>, and <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>.</p>

</div>
</div>
<a class="anchor" id="a83000b816a76017d2c52478529e5bd8a"></a><!-- doxytag: member="UFSHostDevice::read" ref="a83000b816a76017d2c52478529e5bd8a" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> UFSHostDevice::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register access functions </p>
<p>UFSHCD read register.</p>
<p>This function allows the system to read the register entries </p>

<p>Implements <a class="el" href="classPioDevice.html#ab9b039fd7050e7b174e90ebe68284748">PioDevice</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l00928">928</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, <a class="el" href="ufs__device_8hh_source.html#l00239">UFSHostDevice::HCIMem::CMDUCMDARG1</a>, <a class="el" href="ufs__device_8hh_source.html#l00240">UFSHostDevice::HCIMem::CMDUCMDARG2</a>, <a class="el" href="ufs__device_8hh_source.html#l00241">UFSHostDevice::HCIMem::CMDUCMDARG3</a>, <a class="el" href="ufs__device_8hh_source.html#l00238">UFSHostDevice::HCIMem::CMDUICCMDR</a>, <a class="el" href="packet_8hh_source.html#l00525">Packet::getAddr()</a>, <a class="el" href="ufs__device_8hh_source.html#l00193">UFSHostDevice::HCIMem::HCCAP</a>, <a class="el" href="ufs__device_8hh_source.html#l00195">UFSHostDevice::HCIMem::HCHCDDID</a>, <a class="el" href="ufs__device_8hh_source.html#l00196">UFSHostDevice::HCIMem::HCHCPMID</a>, <a class="el" href="ufs__device_8hh_source.html#l00194">UFSHostDevice::HCIMem::HCversion</a>, <a class="el" href="packet_8hh_source.html#l00715">Packet::makeResponse()</a>, <a class="el" href="ufs__device_8hh_source.html#l00204">UFSHostDevice::HCIMem::ORHostControllerEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l00203">UFSHostDevice::HCIMem::ORHostControllerStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l00202">UFSHostDevice::HCIMem::ORInterruptEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l00201">UFSHostDevice::HCIMem::ORInterruptStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l00206">UFSHostDevice::HCIMem::ORUECDL</a>, <a class="el" href="ufs__device_8hh_source.html#l00209">UFSHostDevice::HCIMem::ORUECDME</a>, <a class="el" href="ufs__device_8hh_source.html#l00207">UFSHostDevice::HCIMem::ORUECN</a>, <a class="el" href="ufs__device_8hh_source.html#l00205">UFSHostDevice::HCIMem::ORUECPA</a>, <a class="el" href="ufs__device_8hh_source.html#l00208">UFSHostDevice::HCIMem::ORUECT</a>, <a class="el" href="ufs__device_8hh_source.html#l00210">UFSHostDevice::HCIMem::ORUTRIACR</a>, <a class="el" href="ufs__device_8hh_source.html#l00998">pioDelay</a>, <a class="el" href="ufs__device_8hh_source.html#l01199">regControllerCapabilities</a>, <a class="el" href="ufs__device_8hh_source.html#l01201">regControllerDEVID</a>, <a class="el" href="ufs__device_8hh_source.html#l01206">regControllerEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l01202">regControllerPRODID</a>, <a class="el" href="ufs__device_8hh_source.html#l01205">regControllerStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l01204">regInterruptEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l01203">regInterruptStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l01200">regUFSVersion</a>, <a class="el" href="ufs__device_8hh_source.html#l01223">regUICCommand</a>, <a class="el" href="ufs__device_8hh_source.html#l01224">regUICCommandArg1</a>, <a class="el" href="ufs__device_8hh_source.html#l01225">regUICCommandArg2</a>, <a class="el" href="ufs__device_8hh_source.html#l01226">regUICCommandArg3</a>, <a class="el" href="ufs__device_8hh_source.html#l01208">regUICErrorCodeDataLinkLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01211">regUICErrorCodeDME</a>, <a class="el" href="ufs__device_8hh_source.html#l01209">regUICErrorCodeNetworkLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01207">regUICErrorCodePHYAdapterLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01210">regUICErrorCodeTransportLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01220">regUTPTaskREQDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l01219">regUTPTaskREQListBaseH</a>, <a class="el" href="ufs__device_8hh_source.html#l01218">regUTPTaskREQListBaseL</a>, <a class="el" href="ufs__device_8hh_source.html#l01221">regUTPTaskREQListClear</a>, <a class="el" href="ufs__device_8hh_source.html#l01222">regUTPTaskREQListRunStop</a>, <a class="el" href="ufs__device_8hh_source.html#l01215">regUTPTransferREQDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l01212">regUTPTransferREQINTAGGControl</a>, <a class="el" href="ufs__device_8hh_source.html#l01214">regUTPTransferREQListBaseH</a>, <a class="el" href="ufs__device_8hh_source.html#l01213">regUTPTransferREQListBaseL</a>, <a class="el" href="ufs__device_8hh_source.html#l01216">regUTPTransferREQListClear</a>, <a class="el" href="ufs__device_8hh_source.html#l01217">regUTPTransferREQListRunStop</a>, <a class="el" href="packet__access_8hh_source.html#l00058">Packet::set()</a>, <a class="el" href="ufs__device_8hh_source.html#l00229">UFSHostDevice::HCIMem::TMUTMRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00230">UFSHostDevice::HCIMem::TMUTMRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00232">UFSHostDevice::HCIMem::TMUTMRLCLR</a>, <a class="el" href="ufs__device_8hh_source.html#l00231">UFSHostDevice::HCIMem::TMUTMRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l00233">UFSHostDevice::HCIMem::TMUTMRLRSR</a>, <a class="el" href="ufs__device_8hh_source.html#l00220">UFSHostDevice::HCIMem::TRUTRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00221">UFSHostDevice::HCIMem::TRUTRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00223">UFSHostDevice::HCIMem::TRUTRLCLR</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l00224">UFSHostDevice::HCIMem::TRUTRLRSR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

</div>
</div>
<a class="anchor" id="ac4324a5e5064eca02bdbbdb99c830f73"></a><!-- doxytag: member="UFSHostDevice::readCallback" ref="ac4324a5e5064eca02bdbbdb99c830f73" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::readCallback </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read callback Call back function for the logic units to indicate the completion of a read action. </p>
<p>Read callback, on the way from the disk to the DMA.</p>
<p>Note that this is needed because the read functionality needs to push data structures back to the memory.</p>
<p>Called by the UFSSCSI layer. </p>

<p><p>stats </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02237">2237</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01001">lunAvail</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, <a class="el" href="ufs__device_8hh_source.html#l01173">readGarbageEventQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01118">SSDReadPending</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00504">UFSHostDevice::UFSHostDeviceStats::totalReadDiskTransactions</a>, and <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="ad901dabdffb2047844f124ee5ce1328d"></a><!-- doxytag: member="UFSHostDevice::readDevice" ref="ad901dabdffb2047844f124ee5ce1328d" args="(bool lastTransfer, Addr SCSIStart, uint32_t SCSISize, uint8_t *SCSIDestination, bool no_cache, Event *additional_action)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::readDevice </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>lastTransfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>no_cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>additional_action</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dma transaction function: read device. </p>
<p>Notice that the dma action is from a device perspective, while this function is from an initiator perspective </p>

<p><p>check wether interrupt is needed </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02077">2077</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="dma__device_8cc_source.html#l00157">DmaPort::dmaAction()</a>, <a class="el" href="dma__device_8hh_source.html#l00156">DmaDevice::dmaPort</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01140">readDoneEvent</a>, <a class="el" href="ufs__device_8hh_source.html#l01012">readPendingNum</a>, <a class="el" href="eventq_8hh_source.html#l00330">Event::scheduled()</a>, and <a class="el" href="packet_8hh_source.html#l00087">MemCmd::WriteReq</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>, <a class="el" href="ufs__device_8cc_source.html#l01395">taskHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a716c4c8aa36cdc5b7057bba546e1f0bb"></a><!-- doxytag: member="UFSHostDevice::readDone" ref="a716c4c8aa36cdc5b7057bba546e1f0bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::readDone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read done Started at the end of a transaction after the last read action. </p>
<p>Read done handling function, is only initiated at the end of a transaction.</p>
<p>Cleans up UTP descriptor and other remaining data structures. It also raises the interrupt. </p>

<p><p>Garbage collection; sort out the allocated UTP descriptor</p>
<p>done, generate interrupt if we havent got one already </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01788">1788</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01123">garbage</a>, <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>, <a class="el" href="ufs__device_8hh_source.html#l00201">UFSHostDevice::HCIMem::ORInterruptStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l01140">readDoneEvent</a>, <a class="el" href="ufs__device_8hh_source.html#l01012">readPendingNum</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l01188">UTPTransferREQCOMPL</a>.</p>

</div>
</div>
<a class="anchor" id="a83f5818b278086314c754455d514e03f"></a><!-- doxytag: member="UFSHostDevice::readGarbage" ref="a83f5818b278086314c754455d514e03f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::readGarbage </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read garbage A read from disk data structure can vary in size and is therefor allocated on creation. </p>
<p>After a disk read DMA transfer, the structure needs to be freed.</p>
<p>It can only be destroyed once that particular read action has completed. This function is called on completion of a read from disk action to handle this.</p>
<p>This is done in this function. </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02274">2274</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01173">readGarbageEventQueue</a>, and <a class="el" href="ufs__device_8hh_source.html#l01118">SSDReadPending</a>.</p>

</div>
</div>
<a class="anchor" id="ab93a44d559afdc243605292580c49010"></a><!-- doxytag: member="UFSHostDevice::regStats" ref="ab93a44d559afdc243605292580c49010" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::regStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>register statistics </p>

<p><p>Queue lengths</p>
<p>Amount of data read/written</p>
<p>Average bandwidth for reads and writes</p>
<p>Number of doorbells rung</p>
<p>Latency </p>
</p>

<p>Reimplemented from <a class="el" href="classSimObject.html#afdfbd617cd603ccd8e19c3ceae507261">SimObject</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l00776">776</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01024">activeDoorbells</a>, <a class="el" href="ufs__device_8hh_source.html#l00521">UFSHostDevice::UFSHostDeviceStats::averageDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l00510">UFSHostDevice::UFSHostDeviceStats::averageReadSSDBW</a>, <a class="el" href="ufs__device_8hh_source.html#l00515">UFSHostDevice::UFSHostDeviceStats::averageReadSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00514">UFSHostDevice::UFSHostDeviceStats::averageSCSIQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00511">UFSHostDevice::UFSHostDeviceStats::averageWriteSSDBW</a>, <a class="el" href="ufs__device_8hh_source.html#l00516">UFSHostDevice::UFSHostDeviceStats::averageWriteSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00519">UFSHostDevice::UFSHostDeviceStats::curDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l00498">UFSHostDevice::UFSHostDeviceStats::currentReadSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00497">UFSHostDevice::UFSHostDeviceStats::currentSCSIQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00499">UFSHostDevice::UFSHostDeviceStats::currentWriteSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00525">UFSHostDevice::UFSHostDeviceStats::idleTimes</a>, <a class="el" href="statistics_8hh_source.html#l02543">Stats::Histogram::init()</a>, <a class="el" href="ufs__device_8hh_source.html#l00520">UFSHostDevice::UFSHostDeviceStats::maxDoorbell</a>, <a class="el" href="statistics_8hh_source.html#l00250">Stats::DataWrap&lt; Derived, InfoProxyType &gt;::name()</a>, <a class="el" href="sim__object_8hh_source.html#l00108">SimObject::name()</a>, <a class="el" href="info_8hh_source.html#l00043">Stats::none</a>, <a class="el" href="info_8hh_source.html#l00057">Stats::nozero</a>, <a class="el" href="info_8hh_source.html#l00051">Stats::pdf</a>, <a class="el" href="stat__control_8cc_source.html#l00063">simSeconds</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00504">UFSHostDevice::UFSHostDeviceStats::totalReadDiskTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l00502">UFSHostDevice::UFSHostDeviceStats::totalReadSSD</a>, <a class="el" href="ufs__device_8hh_source.html#l00506">UFSHostDevice::UFSHostDeviceStats::totalReadUFSTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l00505">UFSHostDevice::UFSHostDeviceStats::totalWriteDiskTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l00507">UFSHostDevice::UFSHostDeviceStats::totalWriteUFSTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l00503">UFSHostDevice::UFSHostDeviceStats::totalWrittenSSD</a>, and <a class="el" href="ufs__device_8hh_source.html#l00524">UFSHostDevice::UFSHostDeviceStats::transactionLatency</a>.</p>

</div>
</div>
<a class="anchor" id="a6689fda1fb21622f2f5e547e583ad8f5"></a><!-- doxytag: member="UFSHostDevice::requestHandler" ref="a6689fda1fb21622f2f5e547e583ad8f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::requestHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handler functions. </p>
<p><a class="el" href="classRequest.html">Request</a> handler.</p>
<p>Each function handles a different stage of the transfer. Note that the UFS protocol specifies three types of messages to the host (and devices): 1: Command (to Host specifically) 2: Task (to device; to control flow, not for data) 3: Transfer (to device; to transfer data) request handler. This function finds the cause of the request and triggers the right follow-up action (command handler, task handler, or transferhandler)</p>
<p>Determines where the request comes from and initiates the appropriate actions accordingly. </p>

<p><p>step1 determine what called us step2 determine where to get it Look for any request of which we where not yet aware</p>
<p>Command; general control of the Host controller. no DMA transfer needed</p>
<p>Task; flow control, meant for the device/Logic unit DMA transfer is needed, flash will not be approached</p>
<p>Find the position that is not handled yet</p>
<p>Transfer; Data transfer from or to the disk. There will be DMA transfers, and the flash might be approached. Further commands, are needed to specify the exact command.</p>
<p>Find the position that is not handled yet</p>
<p>stats</p>
<p>step3 start transfer step4 register information; allowing the host to respond in the end</p>
<p>Deleted in readDone, queued in finalUTP </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01230">1230</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01024">activeDoorbells</a>, <a class="el" href="ufs__device_8hh_source.html#l00451">UFSHostDevice::transferStart::address</a>, <a class="el" href="ufs__device_8hh_source.html#l00463">UFSHostDevice::taskStart::address</a>, <a class="el" href="ufs__device_8hh_source.html#l00521">UFSHostDevice::UFSHostDeviceStats::averageDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l00238">UFSHostDevice::HCIMem::CMDUICCMDR</a>, <a class="el" href="ufs__device_8cc_source.html#l01381">commandHandler()</a>, <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="ufs__device_8hh_source.html#l00465">UFSHostDevice::taskStart::done</a>, <a class="el" href="ufs__device_8hh_source.html#l00453">UFSHostDevice::transferStart::done</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="bitfield_8hh_source.html#l00168">findLsbSet()</a>, <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>, <a class="el" href="base_2misc_8hh_source.html#l00209">inform</a>, <a class="el" href="ufs__device_8hh_source.html#l00450">UFSHostDevice::transferStart::mask</a>, <a class="el" href="ufs__device_8hh_source.html#l00462">UFSHostDevice::taskStart::mask</a>, <a class="el" href="arch_2arm_2types_8hh_source.html#l00065">ArmISA::mask</a>, <a class="el" href="ufs__device_8hh_source.html#l00520">UFSHostDevice::UFSHostDeviceStats::maxDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l00201">UFSHostDevice::HCIMem::ORInterruptStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l00452">UFSHostDevice::transferStart::size</a>, <a class="el" href="ufs__device_8hh_source.html#l00464">UFSHostDevice::taskStart::size</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l01045">taskCommandTrack</a>, <a class="el" href="ufs__device_8hh_source.html#l01181">taskEventQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01102">taskInfo</a>, <a class="el" href="ufs__device_8hh_source.html#l00229">UFSHostDevice::HCIMem::TMUTMRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00230">UFSHostDevice::HCIMem::TMUTMRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00231">UFSHostDevice::HCIMem::TMUTMRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01052">transactionStart</a>, <a class="el" href="ufs__device_8hh_source.html#l01183">transferEventQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01103">transferStartInfo</a>, <a class="el" href="ufs__device_8hh_source.html#l01044">transferTrack</a>, <a class="el" href="ufs__device_8hh_source.html#l00220">UFSHostDevice::HCIMem::TRUTRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00221">UFSHostDevice::HCIMem::TRUTRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, <a class="el" href="ufs__device_8hh_source.html#l01190">UICCommandCOMPL</a>, <a class="el" href="statistics_8hh_source.html#l00673">Stats::ScalarBase&lt; Derived, Stor &gt;::value()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>.</p>

</div>
</div>
<a class="anchor" id="abbd53b76896313d34e8c9ed20b5fc79c"></a><!-- doxytag: member="UFSHostDevice::SCSIResume" ref="abbd53b76896313d34e8c9ed20b5fc79c" args="(uint32_t lun_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::SCSIResume </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lun_id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the scsi handling function in the apropriate Logic unit, prepares the right data transfer scheme and kicks it off. </p>
<p>Handles the transfer requests that are given.</p>
<p>There can be three types of transfer. SCSI specific, Reads and writes apart from the data transfer, this also generates its own reply (UPIU response). Information for this reply is stored in <a class="el" href="structUFSHostDevice_1_1transferInfo.html" title="Different events, and scenarios require different types of information.">transferInfo</a> and will be used in transferDone </p>

<p><p>old info, lets form it such that we can understand it</p>
<p>call logic unit to handle SCSI command</p>
<p>build response stating that it was succesful command completion, Logic unit number, and Task tag</p>
<p>SCSI status reply</p>
<p>segment size + EHS length (see UFS standard ch7)</p>
<p>amount of data that will follow</p>
<p>transferdone information packet filling</p>
<p>In this part the data that needs to be transfered will be initiated and the chain of DMA (and potentially) disk transactions will be started.</p>
<p>write transfer</p>
<p>read transfer</p>
<p>not disk related transfer, SCSI maintanance</p>
<p>Transport the SCSI reponse data according to the SG list</p>
<p>safetynet; it has been shown that sg list may be optimistic in the amount of data allocated, which can potentially lead to some garbage data being send over. Hence this construction that finds the least amount of data that needs to be transfered.</p>
<p>Go to the next stage of the answering process </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01519">1519</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00360">UFSHostDevice::UTPTransferReqDesc::commandDescBaseAddrHi</a>, <a class="el" href="ufs__device_8hh_source.html#l00359">UFSHostDevice::UTPTransferReqDesc::commandDescBaseAddrLo</a>, <a class="el" href="arch_2x86_2regs_2misc_8hh_source.html#l00695">X86ISA::count</a>, <a class="el" href="ufs__device_8hh_source.html#l00329">UFSHostDevice::UPIUMessage::dataMsg</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00352">UFSHostDevice::UTPTransferReqDesc::RequestDescHeader::dWord0</a>, <a class="el" href="ufs__device_8hh_source.html#l00381">UFSHostDevice::SCSIReply::expectMore</a>, <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html#a567f254f85ec248db6d91a324ab81b7d">UFSHostDevice::UTPTransferReqDesc::header</a>, <a class="el" href="ufs__device_8hh_source.html#l00378">UFSHostDevice::SCSIReply::LUN</a>, <a class="el" href="ufs__device_8cc_source.html#l02110">manageReadTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l01923">manageWriteTransfer()</a>, <a class="el" href="ufs__device_8hh_source.html#l00379">UFSHostDevice::SCSIReply::message</a>, <a class="el" href="ufs__device_8hh_source.html#l00377">UFSHostDevice::SCSIReply::msgSize</a>, <a class="el" href="ufs__device_8hh_source.html#l00382">UFSHostDevice::SCSIReply::offset</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8hh_source.html#l00367">UFSHostDevice::UTPTransferReqDesc::PRDTableLength</a>, <a class="el" href="ufs__device_8hh_source.html#l00368">UFSHostDevice::UTPTransferReqDesc::PRDTableOffset</a>, <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, <a class="el" href="ufs__device_8hh_source.html#l01074">request_out_datain</a>, <a class="el" href="ufs__device_8hh_source.html#l00363">UFSHostDevice::UTPTransferReqDesc::responseUPIULength</a>, <a class="el" href="ufs__device_8hh_source.html#l00383">UFSHostDevice::SCSIReply::senseCode</a>, <a class="el" href="ufs__device_8hh_source.html#l00380">UFSHostDevice::SCSIReply::senseSize</a>, <a class="el" href="ufs__device_8hh_source.html#l00306">UFSHostDevice::UFSHCDSGEntry::size</a>, <a class="el" href="ufs__device_8hh_source.html#l00376">UFSHostDevice::SCSIReply::status</a>, <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l00304">UFSHostDevice::UFSHCDSGEntry::upperAddr</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a8a08d054940867f114c461a5ed477afb"></a><!-- doxytag: member="UFSHostDevice::SCSIStart" ref="a8a08d054940867f114c461a5ed477afb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::SCSIStart </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer SCSI function. </p>
<p>Obtain LUN and put it in the right LUN queue.</p>
<p>Determines which Logic unit to address and starts the SCSI resume function</p>
<p>Each LUN has its own queue of commands that need to be executed. This is the first instance where it can be determined which Logic unit should handle the transfer. Then check wether it should wait and queue or if it can continue. </p>

<p><p>There are 32 doorbells, so at max there can be 32 transactions</p>
<p>First transfer is done, fetch the next; At this point, the device is busy, not the HC</p>
<p>loading next data packet in case Another LUN is approached in the mean time</p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01474">1474</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00477">UFSHostDevice::SCSIResumeInfo::destination</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8hh_source.html#l01082">SCSIInfo</a>, <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>, <a class="el" href="ufs__device_8hh_source.html#l01183">transferEventQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01103">transferStartInfo</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, and <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="a47801b1a2e4a15d1ae9e2b0cce1dc27a"></a><!-- doxytag: member="UFSHostDevice::serialize" ref="a47801b1a2e4a15d1ae9e2b0cce1dc27a" args="(std::ostream &amp;os)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::serialize </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Serialize; needed to make checkpoints. </p>

<p>Reimplemented from <a class="el" href="classSerializable.html#af4c845a584ff629b4428a1ed02a586f5">Serializable</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02286">2286</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01001">lunAvail</a>, <a class="el" href="serialize_8hh_source.html#l00157">SERIALIZE_ARRAY</a>, <a class="el" href="serialize_8hh_source.html#l00142">SERIALIZE_SCALAR</a>, and <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>.</p>

</div>
</div>
<a class="anchor" id="a375bf9fdfede7b0dbf301dae79ae2328"></a><!-- doxytag: member="UFSHostDevice::setValues" ref="a375bf9fdfede7b0dbf301dae79ae2328" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::setValues </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialization function. </p>
<p>Register init.</p>
<p>Sets the sefault HCI register values </p>

<p><p>The capability register is built up as follows: 31-29 RES; Testmode support; O3 delivery; 64 bit addr; 23-19 RES; 18-16 TM Req slots; 15-5 RES;4-0 # TR slots</p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l00888">888</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00238">UFSHostDevice::HCIMem::CMDUICCMDR</a>, <a class="el" href="ufs__device_8hh_source.html#l00193">UFSHostDevice::HCIMem::HCCAP</a>, <a class="el" href="ufs__device_8hh_source.html#l00195">UFSHostDevice::HCIMem::HCHCDDID</a>, <a class="el" href="ufs__device_8hh_source.html#l00196">UFSHostDevice::HCIMem::HCHCPMID</a>, <a class="el" href="ufs__device_8hh_source.html#l00194">UFSHostDevice::HCIMem::HCversion</a>, <a class="el" href="ufs__device_8hh_source.html#l00203">UFSHostDevice::HCIMem::ORHostControllerStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l00229">UFSHostDevice::HCIMem::TMUTMRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00230">UFSHostDevice::HCIMem::TMUTMRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00231">UFSHostDevice::HCIMem::TMUTMRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l00220">UFSHostDevice::HCIMem::TRUTRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00221">UFSHostDevice::HCIMem::TRUTRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l01002">UFSSlots</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="acdeeb5d6e448679537fc1b783cbc81a3"></a><!-- doxytag: member="UFSHostDevice::taskHandler" ref="acdeeb5d6e448679537fc1b783cbc81a3" args="(struct UTPUPIUTaskReq *request_in, uint32_t req_pos, Addr finaladdress, uint32_t finalsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::taskHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structUFSHostDevice_1_1UTPUPIUTaskReq.html">UTPUPIUTaskReq</a> *&nbsp;</td>
          <td class="paramname"> <em>request_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>req_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>finaladdress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>finalsize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Task handler function. </p>
<p>Handles the tasks that are given.</p>
<p>Handles the tasks send to the devices because there are not many tasks implemented yet this is kept in the Host controller layer</p>
<p>At this point in time, not many tasks have been implemented in the driver. </p>

<p><p>For now, just unpack and acknowledge the task without doing anything. TODO Implement UFS tasks.</p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01395">1395</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00258">UFSHostDevice::UTPUPIUHeader::dWord0</a>, <a class="el" href="ufs__device_8hh_source.html#l00259">UFSHostDevice::UTPUPIUHeader::dWord1</a>, <a class="el" href="ufs__device_8hh_source.html#l00260">UFSHostDevice::UTPUPIUHeader::dWord2</a>, <a class="el" href="ufs__device_8hh_source.html#l00288">UFSHostDevice::UTPUPIUTaskReq::header</a>, <a class="el" href="base_2misc_8hh_source.html#l00209">inform</a>, <a class="el" href="ufs__device_8hh_source.html#l00201">UFSHostDevice::HCIMem::ORInterruptStatus</a>, <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, <a class="el" href="ufs__device_8hh_source.html#l01045">taskCommandTrack</a>, <a class="el" href="ufs__device_8hh_source.html#l00231">UFSHostDevice::HCIMem::TMUTMRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l01189">UTPTaskREQCOMPL</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01347">taskStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a800aaa686c13700089c627fe244591"></a><!-- doxytag: member="UFSHostDevice::taskStart" ref="a0a800aaa686c13700089c627fe244591" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structUFSHostDevice_1_1taskStart.html">UFSHostDevice::taskStart</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Task Start function. </p>
<p>Task start event.</p>
<p>Starts the task handler once the task data structure has arrived </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01347">1347</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01181">taskEventQueue</a>, <a class="el" href="ufs__device_8cc_source.html#l01395">taskHandler()</a>, and <a class="el" href="ufs__device_8hh_source.html#l01102">taskInfo</a>.</p>

</div>
</div>
<a class="anchor" id="ab7284900b111b9990ac2f494a19413c7"></a><!-- doxytag: member="UFSHostDevice::transferDone" ref="ab7284900b111b9990ac2f494a19413c7" args="(Addr responseStartAddr, uint32_t req_pos, struct UTPUPIURSP request_out, uint32_t size, Addr address, uint8_t *destination, bool finished, uint32_t lun_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::transferDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>responseStartAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>req_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structUFSHostDevice_1_1UTPUPIURSP.html">UTPUPIURSP</a>&nbsp;</td>
          <td class="paramname"> <em>request_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>finished</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lun_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>transfer done, the beginning of the final stage of the transfer. </p>
<p>Transfer done.</p>
<p>Acknowledges UPIU frame and prepares the UTP response frame</p>
<p>When the data transfer is done, this function ensures that the application is notified. </p>

<p><p>Test whether SCSI queue hasn't popped prematurely </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01703">1703</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00451">UFSHostDevice::transferStart::address</a>, <a class="el" href="ufs__device_8hh_source.html#l00449">UFSHostDevice::transferStart::destination</a>, <a class="el" href="ufs__device_8hh_source.html#l00453">UFSHostDevice::transferStart::done</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00454">UFSHostDevice::transferStart::lun_id</a>, <a class="el" href="ufs__device_8hh_source.html#l00450">UFSHostDevice::transferStart::mask</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, <a class="el" href="ufs__device_8hh_source.html#l00452">UFSHostDevice::transferStart::size</a>, <a class="el" href="ufs__device_8hh_source.html#l01091">transferEnd</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l01167">UTPEvent</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01671">LUNSignal()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>.</p>

</div>
</div>
<a class="anchor" id="ab99774ea692a4e887e1ca86dfd3e940a"></a><!-- doxytag: member="UFSHostDevice::transferHandler" ref="ab99774ea692a4e887e1ca86dfd3e940a" args="(struct UTPTransferReqDesc *request_in, int req_pos, Addr finaladdress, uint32_t finalsize, uint32_t done)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::transferHandler </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html">UTPTransferReqDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>request_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>req_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>finaladdress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>finalsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>done</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer handler function. </p>
<p>Obtains the SCSI command (if any) Two possibilities: if it contains a SCSI command, then it is a usable message; if it doesnt contain a SCSI message, then it can't be handeld by this code.</p>
<p>Handles the transfers send to the devices Important to understand here is that a Logic unit is not a device (a device can contain multiple logic units). This function analyses the first data structure that has been transfered. Which will tell the host to expect SCSI frames for the rest of the transaction. Note that the host has no indication whatsoever which LU to address. That will follow in the next transaction.</p>
<p>This is the second stage of the transfer. We have the information about where the next command can be found and what the type of command is. The actions that are needed from the device its side are: get the information and store the information such that we can reply. </p>

<p><p>Get the UTP command that has the SCSI command</p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01431">1431</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00360">UFSHostDevice::UTPTransferReqDesc::commandDescBaseAddrHi</a>, <a class="el" href="ufs__device_8hh_source.html#l00359">UFSHostDevice::UTPTransferReqDesc::commandDescBaseAddrLo</a>, <a class="el" href="ufs__device_8hh_source.html#l00477">UFSHostDevice::SCSIResumeInfo::destination</a>, <a class="el" href="ufs__device_8hh_source.html#l00478">UFSHostDevice::SCSIResumeInfo::done</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00354">UFSHostDevice::UTPTransferReqDesc::RequestDescHeader::dWord2</a>, <a class="el" href="ufs__device_8hh_source.html#l00475">UFSHostDevice::SCSIResumeInfo::finalAddress</a>, <a class="el" href="ufs__device_8hh_source.html#l00476">UFSHostDevice::SCSIResumeInfo::finalSize</a>, <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html#a567f254f85ec248db6d91a324ab81b7d">UFSHostDevice::UTPTransferReqDesc::header</a>, <a class="el" href="ufs__device_8hh_source.html#l00367">UFSHostDevice::UTPTransferReqDesc::PRDTableLength</a>, <a class="el" href="ufs__device_8hh_source.html#l00368">UFSHostDevice::UTPTransferReqDesc::PRDTableOffset</a>, <a class="el" href="ufs__device_8hh_source.html#l00474">UFSHostDevice::SCSIResumeInfo::reqPos</a>, <a class="el" href="ufs__device_8hh_source.html#l00473">UFSHostDevice::SCSIResumeInfo::RequestIn</a>, <a class="el" href="eventq_8hh_source.html#l00330">Event::scheduled()</a>, <a class="el" href="ufs__device_8hh_source.html#l01082">SCSIInfo</a>, <a class="el" href="ufs__device_8hh_source.html#l01162">SCSIResumeEvent</a>, <a class="el" href="ufs__device_8hh_source.html#l01183">transferEventQueue</a>, and <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01361">transferStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a807eba6e29725755376b83d17dcea227"></a><!-- doxytag: member="UFSHostDevice::transferStart" ref="a807eba6e29725755376b83d17dcea227" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structUFSHostDevice_1_1transferStart.html">UFSHostDevice::transferStart</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer Start function. </p>
<p>Transfer start event.</p>
<p>Starts the transfer handler once the transfer data structure has arrived </p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01361">1361</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01183">transferEventQueue</a>, <a class="el" href="ufs__device_8cc_source.html#l01431">transferHandler()</a>, and <a class="el" href="ufs__device_8hh_source.html#l01103">transferStartInfo</a>.</p>

</div>
</div>
<a class="anchor" id="a514c422a734637c333e37886f86a528a"></a><!-- doxytag: member="UFSHostDevice::unserialize" ref="a514c422a734637c333e37886f86a528a" args="(Checkpoint *cp, const std::string &amp;section)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::unserialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCheckpoint.html">Checkpoint</a> *&nbsp;</td>
          <td class="paramname"> <em>cp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>section</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unserialize; needed to restore from checkpoints. </p>

<p>Reimplemented from <a class="el" href="classSerializable.html#a5e83c7a6c6266d4e365f6ec7cb949caf">Serializable</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l02303">2303</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l01001">lunAvail</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, <a class="el" href="serialize_8hh_source.html#l00160">UNSERIALIZE_ARRAY</a>, and <a class="el" href="serialize_8hh_source.html#l00144">UNSERIALIZE_SCALAR</a>.</p>

</div>
</div>
<a class="anchor" id="a23d2d9d31b5a11d8e13df699bdb8f3a4"></a><!-- doxytag: member="UFSHostDevice::write" ref="a23d2d9d31b5a11d8e13df699bdb8f3a4" args="(PacketPtr pkt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> UFSHostDevice::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPacket.html">PacketPtr</a>&nbsp;</td>
          <td class="paramname"> <em>pkt</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>UFSHCD write function. </p>
<p>This function allows access to the writeable registers. If any function attempts to write value to an unwriteable register entry, then the value will not be written. </p>

<p>Implements <a class="el" href="classPioDevice.html#ae75ba51da15155f544f9434eea4f9329">PioDevice</a>.</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01066">1066</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00239">UFSHostDevice::HCIMem::CMDUCMDARG1</a>, <a class="el" href="ufs__device_8hh_source.html#l00240">UFSHostDevice::HCIMem::CMDUCMDARG2</a>, <a class="el" href="ufs__device_8hh_source.html#l00241">UFSHostDevice::HCIMem::CMDUCMDARG3</a>, <a class="el" href="ufs__device_8hh_source.html#l00238">UFSHostDevice::HCIMem::CMDUICCMDR</a>, <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="packet__access_8hh_source.html#l00048">Packet::get()</a>, <a class="el" href="packet_8hh_source.html#l00525">Packet::getAddr()</a>, <a class="el" href="packet_8hh_source.html#l00535">Packet::getSize()</a>, <a class="el" href="ufs__device_8hh_source.html#l01053">idlePhaseStart</a>, <a class="el" href="ufs__device_8hh_source.html#l00525">UFSHostDevice::UFSHostDeviceStats::idleTimes</a>, <a class="el" href="packet_8hh_source.html#l00715">Packet::makeResponse()</a>, <a class="el" href="ufs__device_8hh_source.html#l00204">UFSHostDevice::HCIMem::ORHostControllerEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l00203">UFSHostDevice::HCIMem::ORHostControllerStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l00202">UFSHostDevice::HCIMem::ORInterruptEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l00206">UFSHostDevice::HCIMem::ORUECDL</a>, <a class="el" href="ufs__device_8hh_source.html#l00209">UFSHostDevice::HCIMem::ORUECDME</a>, <a class="el" href="ufs__device_8hh_source.html#l00207">UFSHostDevice::HCIMem::ORUECN</a>, <a class="el" href="ufs__device_8hh_source.html#l00205">UFSHostDevice::HCIMem::ORUECPA</a>, <a class="el" href="ufs__device_8hh_source.html#l00208">UFSHostDevice::HCIMem::ORUECT</a>, <a class="el" href="ufs__device_8hh_source.html#l00210">UFSHostDevice::HCIMem::ORUTRIACR</a>, <a class="el" href="base_2misc_8hh_source.html#l00104">panic</a>, <a class="el" href="ufs__device_8hh_source.html#l00998">pioDelay</a>, <a class="el" href="ufs__device_8hh_source.html#l01199">regControllerCapabilities</a>, <a class="el" href="ufs__device_8hh_source.html#l01201">regControllerDEVID</a>, <a class="el" href="ufs__device_8hh_source.html#l01206">regControllerEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l01202">regControllerPRODID</a>, <a class="el" href="ufs__device_8hh_source.html#l01205">regControllerStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l01204">regInterruptEnable</a>, <a class="el" href="ufs__device_8hh_source.html#l01203">regInterruptStatus</a>, <a class="el" href="ufs__device_8hh_source.html#l01200">regUFSVersion</a>, <a class="el" href="ufs__device_8hh_source.html#l01223">regUICCommand</a>, <a class="el" href="ufs__device_8hh_source.html#l01224">regUICCommandArg1</a>, <a class="el" href="ufs__device_8hh_source.html#l01225">regUICCommandArg2</a>, <a class="el" href="ufs__device_8hh_source.html#l01226">regUICCommandArg3</a>, <a class="el" href="ufs__device_8hh_source.html#l01208">regUICErrorCodeDataLinkLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01211">regUICErrorCodeDME</a>, <a class="el" href="ufs__device_8hh_source.html#l01209">regUICErrorCodeNetworkLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01207">regUICErrorCodePHYAdapterLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01210">regUICErrorCodeTransportLayer</a>, <a class="el" href="ufs__device_8hh_source.html#l01220">regUTPTaskREQDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l01219">regUTPTaskREQListBaseH</a>, <a class="el" href="ufs__device_8hh_source.html#l01218">regUTPTaskREQListBaseL</a>, <a class="el" href="ufs__device_8hh_source.html#l01221">regUTPTaskREQListClear</a>, <a class="el" href="ufs__device_8hh_source.html#l01222">regUTPTaskREQListRunStop</a>, <a class="el" href="ufs__device_8hh_source.html#l01215">regUTPTransferREQDoorbell</a>, <a class="el" href="ufs__device_8hh_source.html#l01212">regUTPTransferREQINTAGGControl</a>, <a class="el" href="ufs__device_8hh_source.html#l01214">regUTPTransferREQListBaseH</a>, <a class="el" href="ufs__device_8hh_source.html#l01213">regUTPTransferREQListBaseL</a>, <a class="el" href="ufs__device_8hh_source.html#l01216">regUTPTransferREQListClear</a>, <a class="el" href="ufs__device_8hh_source.html#l01217">regUTPTransferREQListRunStop</a>, <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="statistics_8hh_source.html#l01852">Stats::DistBase&lt; Derived, Stor &gt;::sample()</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00229">UFSHostDevice::HCIMem::TMUTMRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00230">UFSHostDevice::HCIMem::TMUTMRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00232">UFSHostDevice::HCIMem::TMUTMRLCLR</a>, <a class="el" href="ufs__device_8hh_source.html#l00231">UFSHostDevice::HCIMem::TMUTMRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l00233">UFSHostDevice::HCIMem::TMUTMRLRSR</a>, <a class="el" href="ufs__device_8hh_source.html#l00220">UFSHostDevice::HCIMem::TRUTRLBA</a>, <a class="el" href="ufs__device_8hh_source.html#l00221">UFSHostDevice::HCIMem::TRUTRLBAU</a>, <a class="el" href="ufs__device_8hh_source.html#l00223">UFSHostDevice::HCIMem::TRUTRLCLR</a>, <a class="el" href="ufs__device_8hh_source.html#l00222">UFSHostDevice::HCIMem::TRUTRLDBR</a>, <a class="el" href="ufs__device_8hh_source.html#l00224">UFSHostDevice::HCIMem::TRUTRLRSR</a>, <a class="el" href="ufs__device_8hh_source.html#l01007">UFSHCIMem</a>, and <a class="el" href="ufs__device_8hh_source.html#l01191">UICCommandReady</a>.</p>

</div>
</div>
<a class="anchor" id="a8c9877d376633c69e4188d0db080a589"></a><!-- doxytag: member="UFSHostDevice::writeDevice" ref="a8c9877d376633c69e4188d0db080a589" args="(Event *additional_action, bool toDisk, Addr start, int size, uint8_t *destination, uint64_t SCSIDiskOffset, uint32_t lun_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::writeDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&nbsp;</td>
          <td class="paramname"> <em>additional_action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>toDisk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a>&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&nbsp;</td>
          <td class="paramname"> <em>SCSIDiskOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lun_id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA transfer functions These allow the host to push/pull the data to the memory The provided event indicates what the next phase it that will handle the obtained data, or what the follow up action is once the data has been pushed to the memory. </p>
<p>Important to understand about the transfer flow: We have basically three stages, The "system memory" stage, the "device
 buffer" stage and the "disk" stage.</p>
<p>In this model we assume an infinite buffer, or a buffer that is big enough to store all the data in the biggest transaction. Between the three stages are two queues. Those queues store the messages to simulate their transaction from one stage to the next. The manage{Action} function fills up one of the queues and triggers the first event, which causes a chain reaction of events executed once they pass through their queues. For a write action the stages are ordered "system memory", "device buffer" and "disk", whereas the read transfers happen "disk", "device buffer" and "system memory". The dma action in the dma device is written from a bus perspective whereas this model is written from a device perspective. To avoid confusion, the translation between the two has been made in the writeDevice and readDevice funtions. Dma transaction function: write device. Note that the dma action is from a device perspective, while this function is from an initiator perspective </p>

<p><p>check whether transfer is all the way to the flash</p>
<p>destination is an offset here since we are writing to a disk</p>
<p>allocate appropriate buffer</p>
<p>transaction </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01873">1873</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="dma__device_8cc_source.html#l00157">DmaPort::dmaAction()</a>, <a class="el" href="dma__device_8hh_source.html#l00156">DmaDevice::dmaPort</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l00426">UFSHostDevice::transferInfo::filePointer</a>, <a class="el" href="ufs__device_8hh_source.html#l00427">UFSHostDevice::transferInfo::lunID</a>, <a class="el" href="ufs__device_8hh_source.html#l00425">UFSHostDevice::transferInfo::offset</a>, <a class="el" href="packet_8hh_source.html#l00084">MemCmd::ReadReq</a>, <a class="el" href="eventq_8hh_source.html#l00330">Event::scheduled()</a>, <a class="el" href="ufs__device_8hh_source.html#l00424">UFSHostDevice::transferInfo::size</a>, <a class="el" href="ufs__device_8hh_source.html#l01113">SSDWriteinfo</a>, <a class="el" href="ufs__device_8hh_source.html#l01142">writeDoneEvent</a>, and <a class="el" href="ufs__device_8hh_source.html#l01013">writePendingNum</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01923">manageWriteTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>, <a class="el" href="ufs__device_8cc_source.html#l01431">transferHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a8ae430d8a91a02c9c9029e214da46a3a"></a><!-- doxytag: member="UFSHostDevice::writeDone" ref="a8ae430d8a91a02c9c9029e214da46a3a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UFSHostDevice::writeDone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write done After a DMA write with data intended for the disk, this function is called. </p>
<p>Write done handling function.</p>
<p>It ensures that the disk image is modified, and that the correct timing function is triggered.</p>
<p>Is only initiated when the flash is directly approached </p>

<p><p>DMA is done, information no longer needed</p>
<p>If there is nothing on the way, we need to start the events</p>
<p>Write the disk</p>
<p>Move to the second queue, enter the logic unit This is where the disk is approached and the flash transaction is handled SSDWriteDone will take care of the timing</p>
<p>so far, only the DMA part has been handled, lets do the disk delay</p>
<p>stats</p>
<p>initiate the next dma action (if any) </p>
</p>

<p>Definition at line <a class="el" href="ufs__device_8cc_source.html#l01982">1982</a> of file <a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a>.</p>

<p>References <a class="el" href="ufs__device_8hh_source.html#l00516">UFSHostDevice::UFSHostDeviceStats::averageWriteSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l00499">UFSHostDevice::UFSHostDeviceStats::currentWriteSSDQueue</a>, <a class="el" href="ufs__device_8hh_source.html#l01108">dmaWriteInfo</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="ufs__device_8hh_source.html#l01113">SSDWriteinfo</a>, <a class="el" href="ufs__device_8hh_source.html#l01128">stats</a>, <a class="el" href="ufs__device_8hh_source.html#l00505">UFSHostDevice::UFSHostDeviceStats::totalWriteDiskTransactions</a>, <a class="el" href="ufs__device_8hh_source.html#l01067">UFSDevice</a>, <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>, and <a class="el" href="ufs__device_8hh_source.html#l01013">writePendingNum</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a16f2e11f7a738325c2670d4436a741b7"></a><!-- doxytag: member="UFSHostDevice::activeDoorbells" ref="a16f2e11f7a738325c2670d4436a741b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classUFSHostDevice.html#a16f2e11f7a738325c2670d4436a741b7">UFSHostDevice::activeDoorbells</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Statistics helper variables Active doorbells indicates how many doorbells are in teh process of being handled. </p>
<p>Pending doorbells have been handled and are waiting to be acknowledged by the host system. The doorbell register is 32 bits wide, so one byte is enough to keep track of the numbers </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01024">1024</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02349">checkDrain()</a>, <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l00776">regStats()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ae9df73da0e26359e8b0f11d94b79a1c8"></a><!-- doxytag: member="UFSHostDevice::countInt" ref="ae9df73da0e26359e8b0f11d94b79a1c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classUFSHostDevice.html#ae9df73da0e26359e8b0f11d94b79a1c8">UFSHostDevice::countInt</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>interrupt verification This keeps track of the number of interrupts generated. </p>
<p>It is usefull for debug purposes. Make sure that the implemented driver prints the number of interrupts it has handled so far to fully benefit from this feature. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01034">1034</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="ac517d135aba91b1c6afb06a9f298936f"></a><!-- doxytag: member="UFSHostDevice::dmaWriteInfo" ref="ac517d135aba91b1c6afb06a9f298936f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1writeToDiskBurst.html">writeToDiskBurst</a>&gt; <a class="el" href="classUFSHostDevice.html#ac517d135aba91b1c6afb06a9f298936f">UFSHostDevice::dmaWriteInfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information to get a DMA transaction. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01108">1108</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01923">manageWriteTransfer()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<a class="anchor" id="aaeca5f87415474b86c6c3690e68f9e88"></a><!-- doxytag: member="UFSHostDevice::drainManager" ref="aaeca5f87415474b86c6c3690e68f9e88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classUFSHostDevice.html#aaeca5f87415474b86c6c3690e68f9e88">UFSHostDevice::drainManager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>drain manager Needed to be able to implement checkpoint functionality </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01060">1060</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02349">checkDrain()</a>, and <a class="el" href="ufs__device_8cc_source.html#l02320">drain()</a>.</p>

</div>
</div>
<a class="anchor" id="ad79d4e27ba055c7dee98c3faff190ac3"></a><!-- doxytag: member="UFSHostDevice::garbage" ref="ad79d4e27ba055c7dee98c3faff190ac3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1UTPTransferReqDesc.html">UTPTransferReqDesc</a>*&gt; <a class="el" href="classUFSHostDevice.html#ad79d4e27ba055c7dee98c3faff190ac3">UFSHostDevice::garbage</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>garbage queue, ensure clearing of the allocated memory </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01123">1123</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a987ab112c90c4c3eb5d1ccbee82c864a"></a><!-- doxytag: member="UFSHostDevice::gic" ref="a987ab112c90c4c3eb5d1ccbee82c864a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseGic.html">BaseGic</a>* <a class="el" href="classUFSHostDevice.html#a987ab112c90c4c3eb5d1ccbee82c864a">UFSHostDevice::gic</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01000">1000</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="af08a84cb2546369cd56722161985d383"></a><!-- doxytag: member="UFSHostDevice::idlePhaseStart" ref="af08a84cb2546369cd56722161985d383" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classUFSHostDevice.html#af08a84cb2546369cd56722161985d383">UFSHostDevice::idlePhaseStart</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01053">1053</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>.</p>

</div>
</div>
<a class="anchor" id="aaffec0570461ca146db679667d44876f"></a><!-- doxytag: member="UFSHostDevice::intNum" ref="aaffec0570461ca146db679667d44876f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="classUFSHostDevice.html#aaffec0570461ca146db679667d44876f">UFSHostDevice::intNum</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l00999">999</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="a5bca87883eaaf14f7e657d2b912cd20d"></a><!-- doxytag: member="UFSHostDevice::lunAvail" ref="a5bca87883eaaf14f7e657d2b912cd20d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t <a class="el" href="classUFSHostDevice.html#a5bca87883eaaf14f7e657d2b912cd20d">UFSHostDevice::lunAvail</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01001">1001</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01671">LUNSignal()</a>, <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, <a class="el" href="ufs__device_8cc_source.html#l00161">UFSHostDevice::UFSSCSIDevice::SCSICMDHandle()</a>, <a class="el" href="ufs__device_8cc_source.html#l02286">serialize()</a>, <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l02303">unserialize()</a>.</p>

</div>
</div>
<a class="anchor" id="ab90be2d6333101131603513849f1d8aa"></a><!-- doxytag: member="UFSHostDevice::memReadCallback" ref="ab90be2d6333101131603513849f1d8aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCallback.html">Callback</a>* <a class="el" href="classUFSHostDevice.html#ab90be2d6333101131603513849f1d8aa">UFSHostDevice::memReadCallback</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01150">1150</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ad1d3e7f1698d45335b6a5ec7128e04"></a><!-- doxytag: member="UFSHostDevice::pendingDoorbells" ref="a9ad1d3e7f1698d45335b6a5ec7128e04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="classUFSHostDevice.html#a9ad1d3e7f1698d45335b6a5ec7128e04">UFSHostDevice::pendingDoorbells</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01025">1025</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="affa8ce012dc48726416c4cd7cdf1180d"></a><!-- doxytag: member="UFSHostDevice::pioAddr" ref="affa8ce012dc48726416c4cd7cdf1180d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classUFSHostDevice.html#affa8ce012dc48726416c4cd7cdf1180d">UFSHostDevice::pioAddr</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host controller information. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l00996">996</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00915">getAddrRanges()</a>.</p>

</div>
</div>
<a class="anchor" id="a643c0a3668c1597e33b721ebd3d6fded"></a><!-- doxytag: member="UFSHostDevice::pioDelay" ref="a643c0a3668c1597e33b721ebd3d6fded" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classUFSHostDevice.html#a643c0a3668c1597e33b721ebd3d6fded">UFSHostDevice::pioDelay</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l00998">998</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00928">read()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>.</p>

</div>
</div>
<a class="anchor" id="a125c59dd539330089aedb2c4003089ff"></a><!-- doxytag: member="UFSHostDevice::pioSize" ref="a125c59dd539330089aedb2c4003089ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="base_2types_8hh.html#af1bb03d6a4ee096394a6749f0a169232">Addr</a> <a class="el" href="classUFSHostDevice.html#a125c59dd539330089aedb2c4003089ff">UFSHostDevice::pioSize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l00997">997</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00915">getAddrRanges()</a>.</p>

</div>
</div>
<a class="anchor" id="ac08ac50075113848011226ba98121ddb"></a><!-- doxytag: member="UFSHostDevice::readDoneEvent" ref="ac08ac50075113848011226ba98121ddb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;UFSHostDevice::readDone&gt; &gt; <a class="el" href="classUFSHostDevice.html#ac08ac50075113848011226ba98121ddb">UFSHostDevice::readDoneEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfer flow events Basically these events form two queues, one from memory to UFS device (DMA) and one from device to flash (SSD). </p>
<p>The SSD "queue" is maintained by the flash and the lun classes and does not form a queue of events as such, but rather a queue of information. This can be done because the flow of the events is completely in the control of these classes. (Whereas in the DMA case we rely on an external class) </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01140">1140</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a623d595cec1e11d9edaa207ba2d7471f"></a><!-- doxytag: member="UFSHostDevice::readGarbageEventQueue" ref="a623d595cec1e11d9edaa207ba2d7471f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;UFSHostDevice::readGarbage&gt; &gt; <a class="el" href="classUFSHostDevice.html#a623d595cec1e11d9edaa207ba2d7471f">UFSHostDevice::readGarbageEventQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="classEvent.html">Event</a> after a read to clean up the UTP data structures. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01173">1173</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, and <a class="el" href="ufs__device_8cc_source.html#l02274">readGarbage()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c2bb7b9016db0c72c2c1640c9769966"></a><!-- doxytag: member="UFSHostDevice::readPendingNum" ref="a0c2bb7b9016db0c72c2c1640c9769966" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classUFSHostDevice.html#a0c2bb7b9016db0c72c2c1640c9769966">UFSHostDevice::readPendingNum</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Track number of DMA transactions in progress. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01012">1012</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02077">readDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a980f9a20b4cfcc5ac36b10dc8a2dafa9"></a><!-- doxytag: member="UFSHostDevice::request_out_datain" ref="a980f9a20b4cfcc5ac36b10dc8a2dafa9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structUFSHostDevice_1_1SCSIReply.html">SCSIReply</a> <a class="el" href="classUFSHostDevice.html#a980f9a20b4cfcc5ac36b10dc8a2dafa9">UFSHostDevice::request_out_datain</a><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SCSI reply structure, used for direct answering. </p>
<p>Might be refered to during the assembly of the reply (data, and response; e.g. if something goes wrong along the way, the reply will be different) </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01074">1074</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ddaf7164922015fc943e5554fc7ef04"></a><!-- doxytag: member="UFSHostDevice::SCSIInfo" ref="a9ddaf7164922015fc943e5554fc7ef04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structUFSHostDevice_1_1SCSIResumeInfo.html">SCSIResumeInfo</a> <a class="el" href="classUFSHostDevice.html#a9ddaf7164922015fc943e5554fc7ef04">UFSHostDevice::SCSIInfo</a><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>SCSI resume info information structure for SCSI resume. </p>
<p>it keeps track of all the information that is needed to successfully complete the transaction (response addresses, communicated information so far, etc.). </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01082">1082</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01431">transferHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="aadf97748a0d65f612d66caa66694653a"></a><!-- doxytag: member="UFSHostDevice::SCSIResumeEvent" ref="aadf97748a0d65f612d66caa66694653a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;UFSHostDevice::SCSIStart&gt; <a class="el" href="classUFSHostDevice.html#aadf97748a0d65f612d66caa66694653a">UFSHostDevice::SCSIResumeEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The events that control the functionality. </p>
<p>After a doorbell has been set, either a taskevent or a transfer event is scheduled. A transfer event might schedule a SCSI event, all events sequences end with an UTP event, which can be considered as the event which answers the doorbell. Wait for the SCSI specific data to arive </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01162">1162</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01431">transferHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a0c157aeb57ad361cda7a370559ab48cd"></a><!-- doxytag: member="UFSHostDevice::SSDReadPending" ref="a0c157aeb57ad361cda7a370559ab48cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1transferInfo.html">transferInfo</a>&gt; <a class="el" href="classUFSHostDevice.html#a0c157aeb57ad361cda7a370559ab48cd">UFSHostDevice::SSDReadPending</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information from the Disk, waiting to be pushed to the DMA. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01118">1118</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, and <a class="el" href="ufs__device_8cc_source.html#l02274">readGarbage()</a>.</p>

</div>
</div>
<a class="anchor" id="a170d0b32c309d44f0769def6a5d9ae41"></a><!-- doxytag: member="UFSHostDevice::SSDWriteinfo" ref="a170d0b32c309d44f0769def6a5d9ae41" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1transferInfo.html">transferInfo</a>&gt; <a class="el" href="classUFSHostDevice.html#a170d0b32c309d44f0769def6a5d9ae41">UFSHostDevice::SSDWriteinfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Information from DMA transaction to disk. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01113">1113</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<a class="anchor" id="afc5c67585a481a5fdc9f9ccdb110ae5a"></a><!-- doxytag: member="UFSHostDevice::stats" ref="afc5c67585a481a5fdc9f9ccdb110ae5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structUFSHostDevice_1_1UFSHostDeviceStats.html">UFSHostDeviceStats</a> <a class="el" href="classUFSHostDevice.html#afc5c67585a481a5fdc9f9ccdb110ae5a">UFSHostDevice::stats</a><code> [read, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>RequestHandler stats. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01128">1128</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l02110">manageReadTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l01923">manageWriteTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, <a class="el" href="ufs__device_8cc_source.html#l00776">regStats()</a>, <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a2ad1bf7f00d4e944c7ca004b5ddb2c81"></a><!-- doxytag: member="UFSHostDevice::taskCommandTrack" ref="a2ad1bf7f00d4e944c7ca004b5ddb2c81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classUFSHostDevice.html#a2ad1bf7f00d4e944c7ca004b5ddb2c81">UFSHostDevice::taskCommandTrack</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01045">1045</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01395">taskHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a43b88841e2b65caf68dc581c4219e308"></a><!-- doxytag: member="UFSHostDevice::taskEventQueue" ref="a43b88841e2b65caf68dc581c4219e308" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;<a class="el" href="structUFSHostDevice_1_1taskStart.html">UFSHostDevice::taskStart</a>&gt; &gt; <a class="el" href="classUFSHostDevice.html#a43b88841e2b65caf68dc581c4219e308">UFSHostDevice::taskEventQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Multiple tasks transfers can be scheduled at once for the device, the only thing we know for sure about them is that they will happen in a first come first serve order; hence we need to queue. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01181">1181</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01347">taskStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a1417b4e9c1813ae13da072112d05e0"></a><!-- doxytag: member="UFSHostDevice::taskInfo" ref="a3a1417b4e9c1813ae13da072112d05e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1taskStart.html">taskStart</a>&gt; <a class="el" href="classUFSHostDevice.html#a3a1417b4e9c1813ae13da072112d05e0">UFSHostDevice::taskInfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When a task/transfer is started it needs information about the task/transfer it is about to perform. </p>
<p>This is defined in these structures. If multiple tasks/transfers are issued at the same time, they still need to be fetched one by one. They then need to be executed in the order specified by the UFS standard (least significant doorbell first). The tasks/transfers are placed in the queue in that specific order. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01102">1102</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01347">taskStart()</a>.</p>

</div>
</div>
<a class="anchor" id="ac6cef6d6deeb2b63d75b9af0a7530c62"></a><!-- doxytag: member="UFSHostDevice::transactionStart" ref="ac6cef6d6deeb2b63d75b9af0a7530c62" args="[32]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> <a class="el" href="classUFSHostDevice.html#ac6cef6d6deeb2b63d75b9af0a7530c62">UFSHostDevice::transactionStart</a>[32]<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper for latency stats These variables keep track of the latency for every doorbell. </p>
<p>Eventually the latenmcies will be put in a histogram. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01052">1052</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e5c2208e40f9b90cb48fe8a73328abb"></a><!-- doxytag: member="UFSHostDevice::transferDoneCallback" ref="a0e5c2208e40f9b90cb48fe8a73328abb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCallback.html">Callback</a>* <a class="el" href="classUFSHostDevice.html#a0e5c2208e40f9b90cb48fe8a73328abb">UFSHostDevice::transferDoneCallback</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callbacks for the logic units. </p>
<p>One to indicate the completion of a transaction, the other one to indicate the completion of a read action. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01149">1149</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="adaa5cb5f2698e8d845d41615dc0ea074"></a><!-- doxytag: member="UFSHostDevice::transferEnd" ref="adaa5cb5f2698e8d845d41615dc0ea074" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1transferStart.html">transferStart</a>&gt; <a class="el" href="classUFSHostDevice.html#adaa5cb5f2698e8d845d41615dc0ea074">UFSHostDevice::transferEnd</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>To finish the transaction one needs information about the original message. </p>
<p>This is stored in this queue transferEnd uses the same structure as transferStartInfo, because all the information it needs is in there. It improves readability in the cc file. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01091">1091</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a906cf4e1a2bd3226f9dc2ab047935cde"></a><!-- doxytag: member="UFSHostDevice::transferEventQueue" ref="a906cf4e1a2bd3226f9dc2ab047935cde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;<a class="el" href="structUFSHostDevice_1_1transferStart.html">UFSHostDevice::transferStart</a>&gt; &gt; <a class="el" href="classUFSHostDevice.html#a906cf4e1a2bd3226f9dc2ab047935cde">UFSHostDevice::transferEventQueue</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01183">1183</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>, <a class="el" href="ufs__device_8cc_source.html#l01431">transferHandler()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01361">transferStart()</a>.</p>

</div>
</div>
<a class="anchor" id="ac72374443f2d7b5088387317d84f3be7"></a><!-- doxytag: member="UFSHostDevice::transferStartInfo" ref="ac72374443f2d7b5088387317d84f3be7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;struct <a class="el" href="structUFSHostDevice_1_1transferStart.html">transferStart</a>&gt; <a class="el" href="classUFSHostDevice.html#ac72374443f2d7b5088387317d84f3be7">UFSHostDevice::transferStartInfo</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01103">1103</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01361">transferStart()</a>.</p>

</div>
</div>
<a class="anchor" id="a9fdd54e78b6c6797f78e869fe67b1362"></a><!-- doxytag: member="UFSHostDevice::transferTrack" ref="a9fdd54e78b6c6797f78e869fe67b1362" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classUFSHostDevice.html#a9fdd54e78b6c6797f78e869fe67b1362">UFSHostDevice::transferTrack</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Track the transfer This is allows the driver to "group" certain transfers together by using a tag in the UPIU. </p>
<p>The messages with the same tag should be handled together, i.e. their doorbells should be cleared when they are all done. but we need to keep track of the ones we already handled, this integer shadows the doorbells to allow this behaviour. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01044">1044</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="af41e655708399351b96c0d65d77adb04"></a><!-- doxytag: member="UFSHostDevice::UFSDevice" ref="af41e655708399351b96c0d65d77adb04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1vector.html">std::vector</a>&lt;<a class="el" href="classUFSHostDevice_1_1UFSSCSIDevice.html">UFSSCSIDevice</a>*&gt; <a class="el" href="classUFSHostDevice.html#af41e655708399351b96c0d65d77adb04">UFSHostDevice::UFSDevice</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>logic units connected to the UFS Host device Note again that the "device" as such is represented by one or multiple logic units. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01067">1067</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l01671">LUNSignal()</a>, <a class="el" href="ufs__device_8cc_source.html#l02110">manageReadTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l01923">manageWriteTransfer()</a>, <a class="el" href="ufs__device_8cc_source.html#l02237">readCallback()</a>, <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>, <a class="el" href="ufs__device_8cc_source.html#l01474">SCSIStart()</a>, <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>, <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a42bb5c0dfc5f68271dfa9341da2f90c5"></a><!-- doxytag: member="UFSHostDevice::UFSHCIMem" ref="a42bb5c0dfc5f68271dfa9341da2f90c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUFSHostDevice_1_1HCIMem.html">HCIMem</a> <a class="el" href="classUFSHostDevice.html#a42bb5c0dfc5f68271dfa9341da2f90c5">UFSHostDevice::UFSHCIMem</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Host controller memory. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01007">1007</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l02349">checkDrain()</a>, <a class="el" href="ufs__device_8cc_source.html#l01837">clearInterrupt()</a>, <a class="el" href="ufs__device_8cc_source.html#l01381">commandHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l02320">drain()</a>, <a class="el" href="ufs__device_8cc_source.html#l01742">finalUTP()</a>, <a class="el" href="ufs__device_8cc_source.html#l01816">generateInterrupt()</a>, <a class="el" href="ufs__device_8cc_source.html#l00928">read()</a>, <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>, <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01519">SCSIResume()</a>, <a class="el" href="ufs__device_8cc_source.html#l02286">serialize()</a>, <a class="el" href="ufs__device_8cc_source.html#l00888">setValues()</a>, <a class="el" href="ufs__device_8cc_source.html#l01395">taskHandler()</a>, <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>, <a class="el" href="ufs__device_8cc_source.html#l02303">unserialize()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>.</p>

</div>
</div>
<a class="anchor" id="acf02882943451c5bf52ba1a261e9f217"></a><!-- doxytag: member="UFSHostDevice::UFSSlots" ref="acf02882943451c5bf52ba1a261e9f217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="classUFSHostDevice.html#acf02882943451c5bf52ba1a261e9f217">UFSHostDevice::UFSSlots</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01002">1002</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l00888">setValues()</a>, and <a class="el" href="ufs__device_8cc_source.html#l00719">UFSHostDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="a576c3aae41360d989456d8f9cb5ed3f1"></a><!-- doxytag: member="UFSHostDevice::UICCommandCOMPL" ref="a576c3aae41360d989456d8f9cb5ed3f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classUFSHostDevice.html#a576c3aae41360d989456d8f9cb5ed3f1">UFSHostDevice::UICCommandCOMPL</a> = 0x400<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01190">1190</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01230">requestHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a98894aa7d578f6d0c2535f95decbd626"></a><!-- doxytag: member="UFSHostDevice::UICCommandReady" ref="a98894aa7d578f6d0c2535f95decbd626" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classUFSHostDevice.html#a98894aa7d578f6d0c2535f95decbd626">UFSHostDevice::UICCommandReady</a> = 0x08<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01191">1191</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01066">write()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cf81d83001c40ab22899e26a798856a"></a><!-- doxytag: member="UFSHostDevice::UTPEvent" ref="a8cf81d83001c40ab22899e26a798856a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;UFSHostDevice::finalUTP&gt; <a class="el" href="classUFSHostDevice.html#a8cf81d83001c40ab22899e26a798856a">UFSHostDevice::UTPEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for the moment where we can send the last frame. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01167">1167</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01703">transferDone()</a>.</p>

</div>
</div>
<a class="anchor" id="acb934c31fb64417a09fc26151b738600"></a><!-- doxytag: member="UFSHostDevice::UTPTaskREQCOMPL" ref="acb934c31fb64417a09fc26151b738600" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classUFSHostDevice.html#acb934c31fb64417a09fc26151b738600">UFSHostDevice::UTPTaskREQCOMPL</a> = 0x200<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01189">1189</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01395">taskHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="a27697d97aa3d4781af6668f558d98cd7"></a><!-- doxytag: member="UFSHostDevice::UTPTransferREQCOMPL" ref="a27697d97aa3d4781af6668f558d98cd7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int <a class="el" href="classUFSHostDevice.html#a27697d97aa3d4781af6668f558d98cd7">UFSHostDevice::UTPTransferREQCOMPL</a> = 0x01<code> [static, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bits of interest within UFS data packages. </p>

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01188">1188</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01788">readDone()</a>.</p>

</div>
</div>
<a class="anchor" id="a7b9c9749123042c563cd1d6fde9074e7"></a><!-- doxytag: member="UFSHostDevice::writeDoneEvent" ref="a7b9c9749123042c563cd1d6fde9074e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;<a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classUFSHostDevice.html">UFSHostDevice</a>, &amp;UFSHostDevice::writeDone&gt; &gt; <a class="el" href="classUFSHostDevice.html#a7b9c9749123042c563cd1d6fde9074e7">UFSHostDevice::writeDoneEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01142">1142</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ef599ebb3035b24426fd3a88e41cb5d"></a><!-- doxytag: member="UFSHostDevice::writePendingNum" ref="a1ef599ebb3035b24426fd3a88e41cb5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classUFSHostDevice.html#a1ef599ebb3035b24426fd3a88e41cb5d">UFSHostDevice::writePendingNum</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="ufs__device_8hh_source.html#l01013">1013</a> of file <a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a>.</p>

<p>Referenced by <a class="el" href="ufs__device_8cc_source.html#l01873">writeDevice()</a>, and <a class="el" href="ufs__device_8cc_source.html#l01982">writeDone()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dev/arm/<a class="el" href="ufs__device_8hh_source.html">ufs_device.hh</a></li>
<li>dev/arm/<a class="el" href="ufs__device_8cc_source.html">ufs_device.cc</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Mon Dec 7 02:33:23 2015 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.6.1</small></address>

</body>
</html>
