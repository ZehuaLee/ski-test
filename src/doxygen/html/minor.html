<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: Inside the Minor CPU model</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="minor">Inside the <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> CPU model </a></h1><p>This document contains a description of the structure and function of the <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> gem5 in-order processor model. It is recommended reading for anyone who wants to understand Minor's internal organisation, design decisions, C++ implementation and Python configuration. A familiarity with gem5 and some of its internal structures is assumed. This document is meant to be read alongside the <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> source code and to explain its general structure without being too slavish about naming every function and data type.</p>
<h2><a class="anchor" id="whatis">
What is Minor?</a></h2>
<p><a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> is an in-order processor model with a fixed pipeline but configurable data structures and execute behaviour. It is intended to be used to model processors with strict in-order execution behaviour and allows visualisation of an instruction's position in the pipeline through the MinorTrace/minorview.py format/tool. The intention is to provide a framework for micro-architecturally correlating the model with a particular, chosen processor with similar capabilities.</p>
<h2><a class="anchor" id="philo">
Design philosophy</a></h2>
<h3><a class="anchor" id="mt">
Multithreading</a></h3>
<p>The model isn't currently capable of multithreading but there are THREAD comments in key places where stage data needs to be arrayed to support multithreading.</p>
<h3><a class="anchor" id="structs">
Data structures</a></h3>
<p>Decorating data structures with large amounts of life-cycle information is avoided. Only instructions (<a class="el" href="classMinor_1_1MinorDynInst.html" title="Dynamic instruction for Minor.">MinorDynInst</a>) contain a significant proportion of their data content whose values are not set at construction.</p>
<p>All internal structures have fixed sizes on construction. Data held in queues and FIFOs (<a class="el" href="classMinor_1_1MinorBuffer.html" title="TimeBuffer with MinorTrace and Named interfaces.">MinorBuffer</a>, <a class="el" href="classMinor_1_1FUPipeline.html" title="A functional unit configured from a MinorFU object.">FUPipeline</a>) should have a <a class="el" href="classMinor_1_1BubbleIF.html" title="Interface class for data with &#39;bubble&#39; values.">BubbleIF</a> interface to allow a distinct 'bubble'/no data value option for each type.</p>
<p>Inter-stage 'struct' data is packaged in structures which are passed by value. Only <a class="el" href="classMinor_1_1MinorDynInst.html" title="Dynamic instruction for Minor.">MinorDynInst</a>, the line data in <a class="el" href="classMinor_1_1ForwardLineData.html" title="Line fetch data in the forward direction.">ForwardLineData</a> and the memory-interfacing objects <a class="el" href="classMinor_1_1Fetch1_1_1FetchRequest.html" title="Memory access queuing.">Fetch1::FetchRequest</a> and <a class="el" href="classMinor_1_1LSQ_1_1LSQRequest.html" title="Derived SenderState to carry data access info.">LSQ::LSQRequest</a> are 'new' allocated while running the model.</p>
<h2><a class="anchor" id="model">
Model structure</a></h2>
<p>Objects of class <a class="el" href="classMinorCPU.html" title="MinorCPU is an in-order CPU model with four fixed pipeline stages:.">MinorCPU</a> are provided by the model to gem5. <a class="el" href="classMinorCPU.html" title="MinorCPU is an in-order CPU model with four fixed pipeline stages:.">MinorCPU</a> implements the interfaces of (cpu.hh) and can provide data and instruction interfaces for connection to a cache system. The model is configured in a similar way to other gem5 models through Python. That configuration is passed on to <a class="el" href="classMinorCPU.html#a36a7ec6a8c5a6d27fd013d8b0238029d" title="pipeline is a container for the clockable pipeline stage objects.">MinorCPU::pipeline</a> (of class <a class="el" href="classMinor_1_1Pipeline.html" title="The constructed pipeline.">Pipeline</a>) which actually implements the processor pipeline.</p>
<p>The hierarchy of major unit ownership from <a class="el" href="classMinorCPU.html" title="MinorCPU is an in-order CPU model with four fixed pipeline stages:.">MinorCPU</a> down looks like this:</p>
<ul>
<li>
<a class="el" href="classMinorCPU.html" title="MinorCPU is an in-order CPU model with four fixed pipeline stages:.">MinorCPU</a> <ul>
<li>
<a class="el" href="classMinor_1_1Pipeline.html" title="The constructed pipeline.">Pipeline</a> - container for the pipeline, owns the cyclic 'tick' event mechanism and the idling (cycle skipping) mechanism. <ul>
<li>
<a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> - instruction fetch unit responsible for fetching cache lines (or parts of lines from the I-cache interface) <ul>
<li>
<a class="el" href="classMinor_1_1Fetch1_1_1IcachePort.html" title="Exposable fetch port.">Fetch1::IcachePort</a> - interface to the I-cache from <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> </li>
</ul>
</li>
<li>
<a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> - line to instruction decomposition </li>
<li>
<a class="el" href="classMinor_1_1Decode.html">Decode</a> - instruction to micro-op decomposition </li>
<li>
<a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> - instruction execution and data memory interface <ul>
<li>
<a class="el" href="classMinor_1_1LSQ.html">LSQ</a> - load store queue for memory ref. instructions </li>
<li>
<a class="el" href="classMinor_1_1LSQ_1_1DcachePort.html" title="Exposable data port.">LSQ::DcachePort</a> - interface to the D-cache from <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="keystruct">
Key data structures</a></h2>
<h3><a class="anchor" id="ids">
Instruction and line identity: InstId (dyn_inst.hh)</a></h3>
<p>An <a class="el" href="classMinor_1_1InstId.html" title="Id for lines and instructions.">InstId</a> contains the sequence numbers and thread numbers that describe the life cycle and instruction stream affiliations of individual fetched cache lines and instructions.</p>
<p>An <a class="el" href="classMinor_1_1InstId.html" title="Id for lines and instructions.">InstId</a> is printed in one of the following forms:</p>
<ul>
<li>T/S.P/L - for fetched cache lines</li>
<li>T/S.P/L/F - for instructions before <a class="el" href="classMinor_1_1Decode.html">Decode</a></li>
<li>T/S.P/L/F.E - for instructions from <a class="el" href="classMinor_1_1Decode.html">Decode</a> onwards</li>
</ul>
<p>for example:</p>
<ul>
<li>0/10.12/5/6.7</li>
</ul>
<p>InstId's fields are:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b>Field</b> </p>
</td><td><p><b>Symbol</b> </p>
</td><td><p><b>Generated by</b> </p>
</td><td><p><b>Checked by</b> </p>
</td><td><p><b>Function</b> </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#a852c2408f148471a8b88d761893a8991" title="The thread to which this line/instruction belongs.">InstId::threadId</a> </p>
</td><td><p>T </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> </p>
</td><td><p>Everywhere the thread number is needed </p>
</td><td><p>Thread number (currently always 0). </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#a1cd0f1ebb34403c83c1d114475952dbd" title="The &#39;stream&#39; this instruction belongs to.">InstId::streamSeqNum</a> </p>
</td><td><p>S </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a>, <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>, <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> (to discard lines/insts) </p>
</td><td><p>Stream sequence number as chosen by <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a>. Stream sequence numbers change after changes of PC (branches, exceptions) in <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> and are used to separate pre and post branch instruction streams. </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#acee87c54561f00475b9bf9fc24a31b39" title="The predicted qualifier to stream, attached by Fetch2 as a consequence of branch...">InstId::predictionSeqNum</a> </p>
</td><td><p>P </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> (while discarding lines after prediction) </p>
</td><td><p>Prediction sequence numbers represent branch prediction decisions. This is used by <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> to mark lines/instructions according to the last followed branch prediction made by <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>. <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> can signal to <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> that it should change its fetch address and mark lines with a new prediction sequence number (which it will only do if the stream sequence number <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> expects matches that of the request).  </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#a723cfe9c42e53055d81e981317f25c24" title="Line sequence number.">InstId::lineSeqNum</a> </p>
</td><td><p>L </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> </p>
</td><td><p>(Just for debugging) </p>
</td><td><p>Line fetch sequence number of this cache line or the line this instruction was extracted from.  </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#a06677e68051a2a52f384e55e9368e33d" title="Fetch sequence number.">InstId::fetchSeqNum</a> </p>
</td><td><p>F </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> (as the inst. sequence number for branches) </p>
</td><td><p>Instruction fetch order assigned by <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> when lines are decomposed into instructions.  </p>
<p></p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1InstId.html#a064b0e4480268559e68510311be2a9b0" title="&#39;Execute&#39; sequence number.">InstId::execSeqNum</a> </p>
</td><td><p>E </p>
</td><td><p><a class="el" href="classMinor_1_1Decode.html">Decode</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> (to check instruction identity in queues/FUs/LSQ) </p>
</td><td><p>Instruction order after micro-op decomposition. </p>
<p></p>
</td></tr>
</table>
<p>The sequence number fields are all independent of each other and although, for instance, <a class="el" href="classMinor_1_1InstId.html#a064b0e4480268559e68510311be2a9b0" title="&#39;Execute&#39; sequence number.">InstId::execSeqNum</a> for an instruction will always be &gt;= <a class="el" href="classMinor_1_1InstId.html#a06677e68051a2a52f384e55e9368e33d" title="Fetch sequence number.">InstId::fetchSeqNum</a>, the comparison is not useful.</p>
<p>The originating stage of each sequence number field keeps a counter for that field which can be incremented in order to generate new, unique numbers.</p>
<h3><a class="anchor" id="insts">
Instructions: MinorDynInst (dyn_inst.hh)</a></h3>
<p><a class="el" href="classMinor_1_1MinorDynInst.html" title="Dynamic instruction for Minor.">MinorDynInst</a> represents an instruction's progression through the pipeline. An instruction can be three things:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b>Thing</b> </p>
</td><td><p><b>Predicate</b> </p>
</td><td><p><b>Explanation</b>  </p>
</td></tr>
<tr>
<td><p>A bubble </p>
</td><td><p><a class="el" href="classMinor_1_1MinorDynInst.html#a50ecd2b61fc6c75ccf53907832309b41" title="The BubbleIF interface.">MinorDynInst::isBubble()</a> </p>
</td><td><p>no instruction at all, just a space-filler  </p>
</td></tr>
<tr>
<td><p>A fault </p>
</td><td><p><a class="el" href="classMinor_1_1MinorDynInst.html#ab047619bab7e1bb143fbc51cecc29263" title="Is this a fault rather than instruction.">MinorDynInst::isFault()</a> </p>
</td><td><p>a fault to pass down the pipeline in an instruction's clothing  </p>
</td></tr>
<tr>
<td><p>A decoded instruction </p>
</td><td><p><a class="el" href="classMinor_1_1MinorDynInst.html#a4668fe7b16414641a0f231e9e7e1e512" title="Is this a real instruction.">MinorDynInst::isInst()</a> </p>
</td><td><p>instructions are actually passed to the gem5 decoder in <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> and so are created fully decoded. <a class="el" href="classMinor_1_1MinorDynInst.html#adebb81c5776f743689b973c4f5b22363">MinorDynInst::staticInst</a> is the decoded instruction form.  </p>
</td></tr>
</table>
<p>Instructions are reference counted using the gem5 <a class="el" href="classRefCountingPtr.html" title="If you want a reference counting pointer to a mutable object, create it like this:...">RefCountingPtr</a> (<a class="el" href="refcnt_8hh.html" title="Classes for managing reference counted objects.">base/refcnt.hh</a>) wrapper. They therefore usually appear as MinorDynInstPtr in code. Note that as <a class="el" href="classRefCountingPtr.html" title="If you want a reference counting pointer to a mutable object, create it like this:...">RefCountingPtr</a> initialises as nullptr rather than an object that supports <a class="el" href="classMinor_1_1BubbleIF.html#a7ce121301dba2e89b94235d96bf339ae">BubbleIF::isBubble</a>, passing raw MinorDynInstPtrs to <a class="el" href="classMinor_1_1Queue.html" title="Wrapper for a queue type to act as a pipeline stage input queue.">Queue</a>s and other similar structures from stage.hh without boxing is dangerous.</p>
<h3><a class="anchor" id="fld">
ForwardLineData (pipe_data.hh)</a></h3>
<p><a class="el" href="classMinor_1_1ForwardLineData.html" title="Line fetch data in the forward direction.">ForwardLineData</a> is used to pass cache lines from <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> to <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>. Like <a class="el" href="classMinor_1_1MinorDynInst.html" title="Dynamic instruction for Minor.">MinorDynInst</a>s, they can be bubbles (<a class="el" href="classMinor_1_1ForwardLineData.html#adb9249825e40e8786fb1c086893c7179">ForwardLineData::isBubble()</a>), fault-carrying or can contain a line (partial line) fetched by <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a>. The data carried by <a class="el" href="classMinor_1_1ForwardLineData.html" title="Line fetch data in the forward direction.">ForwardLineData</a> is owned by a <a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system...">Packet</a> object returned from memory and is explicitly memory managed and do must be deleted once processed (by <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> deleting the <a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system...">Packet</a>).</p>
<h3><a class="anchor" id="fid">
ForwardInstData (pipe_data.hh)</a></h3>
<p><a class="el" href="classMinor_1_1ForwardInstData.html" title="Forward flowing data between Fetch2,Decode,Execute carrying a packet of instructions...">ForwardInstData</a> can contain up to <a class="el" href="classMinor_1_1ForwardInstData.html#a47f26f922938d664b5e858adeebfe851" title="Number of instructions carried by this object.">ForwardInstData::width()</a> instructions in its <a class="el" href="classMinor_1_1ForwardInstData.html#ab54a61c683376aaf5a12ea19ab758340" title="Array of carried insts, ref counted.">ForwardInstData::insts</a> vector. This structure is used to carry instructions between <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>, <a class="el" href="classMinor_1_1Decode.html">Decode</a> and <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> and to store input buffer vectors in <a class="el" href="classMinor_1_1Decode.html">Decode</a> and <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a>.</p>
<h3><a class="anchor" id="fr">
Fetch1::FetchRequest (fetch1.hh)</a></h3>
<p>FetchRequests represent I-cache line fetch requests. The are used in the memory queues of <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and are pushed into/popped from <a class="el" href="classPacket.html#ad1dd4fa4370e508806fe4a8253a0ad12" title="This packet&#39;s sender state.">Packet::senderState</a> while traversing the memory system.</p>
<p>FetchRequests contain a memory system <a class="el" href="classRequest.html">Request</a> (<a class="el" href="request_8hh.html" title="Declaration of a request, the overall memory request consisting of the parts of the...">mem/request.hh</a>) for that fetch access, a packet (<a class="el" href="classPacket.html" title="A Packet is used to encapsulate a transfer between two objects in the memory system...">Packet</a>, <a class="el" href="packet_8hh.html" title="Declaration of the Packet class.">mem/packet.hh</a>), if the request gets to memory, and a fault field that can be populated with a TLB-sourced prefetch fault (if any).</p>
<h3><a class="anchor" id="lsqr">
LSQ::LSQRequest (execute.hh)</a></h3>
<p>LSQRequests are similar to FetchRequests but for D-cache accesses. They carry the instruction associated with a memory access.</p>
<h2><a class="anchor" id="pipeline">
The pipeline</a></h2>
<div class="fragment"><pre class="fragment">
------------------------------------------------------------------------------
    Key:

    [] : inter-stage BufferBuffer
    ,--.
    |  | : pipeline stage
    `--'
    ---&gt; : forward communication
    &lt;--- : backward communication

    rv : reservation information for input buffers

                ,------.     ,------.     ,------.     ,-------.
 (from  --[]-v-&gt;|Fetch1|-[]-&gt;|Fetch2|-[]-&gt;|Decode|-[]-&gt;|Execute|--&gt; (to Fetch1
 Execute)    |  |      |&lt;-[]-|      |&lt;-rv-|      |&lt;-rv-|       |     &amp; Fetch2)
             |  `------'&lt;-rv-|      |     |      |     |       |
             `--------------&gt;|      |     |      |     |       |
                             `------'     `------'     `-------'
------------------------------------------------------------------------------
</pre></div><p>The four pipeline stages are connected together by <a class="el" href="classMinor_1_1MinorBuffer.html" title="TimeBuffer with MinorTrace and Named interfaces.">MinorBuffer</a> FIFO (stage.hh, derived ultimately from <a class="el" href="classTimeBuffer.html">TimeBuffer</a>) structures which allow inter-stage delays to be modelled. There is a <a class="el" href="classMinor_1_1MinorBuffer.html" title="TimeBuffer with MinorTrace and Named interfaces.">MinorBuffer</a>s between adjacent stages in the forward direction (for example: passing lines from <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> to <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>) and, between <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> and <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a>, a buffer in the backwards direction carrying branch predictions.</p>
<p>Stages <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>, <a class="el" href="classMinor_1_1Decode.html">Decode</a> and <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> have input buffers which, each cycle, can accept input data from the previous stage and can hold that data if the stage is not ready to process it. Input buffers store data in the same form as it is received and so <a class="el" href="classMinor_1_1Decode.html">Decode</a> and Execute's input buffers contain the output instruction vector (<a class="el" href="classMinor_1_1ForwardInstData.html" title="Forward flowing data between Fetch2,Decode,Execute carrying a packet of instructions...">ForwardInstData</a> (<a class="el" href="pipe__data_8hh.html" title="Contains class definitions for data flowing between pipeline stages in the top-level...">pipe_data.hh</a>)) from their previous stages with the instructions and bubbles in the same positions as a single buffer entry.</p>
<p>Stage input buffers provide a <a class="el" href="classMinor_1_1Reservable.html" title="Base class for space reservation requestable objects.">Reservable</a> (stage.hh) interface to their previous stages, to allow slots to be reserved in their input buffers, and communicate their input buffer occupancy backwards to allow the previous stage to plan whether it should make an output in a given cycle.</p>
<h3><a class="anchor" id="events">
Event handling: MinorActivityRecorder (activity.hh,</a></h3>
<p><a class="el" href="pipeline_8hh.html" title="The constructed pipeline.">pipeline.hh</a>)</p>
<p><a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> is essentially a cycle-callable model with some ability to skip cycles based on pipeline activity. External events are mostly received by callbacks (e.g. <a class="el" href="classMinor_1_1Fetch1_1_1IcachePort.html#aec62b3d89dfe61e8528cdcdf3729eeab" title="Receive a timing response from the slave port.">Fetch1::IcachePort::recvTimingResp</a>) and cause the pipeline to be woken up to service advancing request queues.</p>
<p><a class="el" href="classTicked.html" title="Ticked attaches gem5&#39;s event queue/scheduler to evaluate calls and provides a...">Ticked</a> (sim/ticked.hh) is a base class bringing together an evaluate member function and a provided <a class="el" href="classSimObject.html" title="Abstract superclass for simulation objects.">SimObject</a>. It provides a <a class="el" href="classTicked.html#a798d1e248c27161de6eb2bc6fef5e425" title="Start ticking.">Ticked::start</a>/stop interface to start and pause clock events from being periodically issued. <a class="el" href="classMinor_1_1Pipeline.html" title="The constructed pipeline.">Pipeline</a> is a derived class of <a class="el" href="classTicked.html" title="Ticked attaches gem5&#39;s event queue/scheduler to evaluate calls and provides a...">Ticked</a>.</p>
<p>During evaluate calls, stages can signal that they still have work to do in the next cycle by calling either <a class="el" href="classMinorCPU.html#ae3b03c96ee234e2c5c6c68f4567245a7" title="Activity recording for pipeline.">MinorCPU::activityRecorder</a>-&gt;activity() (for non-callable related activity) or MinorCPU::wakeupOnEvent(&lt;stageId&gt;) (for stage callback-related 'wakeup' activity).</p>
<p><a class="el" href="classMinor_1_1Pipeline.html#aa73853210f59f6d9cd217da138de390d" title="A custom evaluate allows report in the right place (between stages and pipeline advance)...">Pipeline::evaluate</a> contains calls to evaluate for each unit and a test for pipeline idling which can turns off the clock tick if no unit has signalled that it may become active next cycle.</p>
<p>Within <a class="el" href="classMinor_1_1Pipeline.html" title="The constructed pipeline.">Pipeline</a> (<a class="el" href="pipeline_8hh.html" title="The constructed pipeline.">pipeline.hh</a>), the stages are evaluated in reverse order (and so will evaluate in reverse order) and their backwards data can be read immediately after being written in each cycle allowing output decisions to be 'perfect' (allowing synchronous stalling of the whole pipeline). Branch predictions from <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> to <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> can also be transported in 0 cycles making fetch1ToFetch2BackwardDelay the only configurable delay which can be set as low as 0 cycles.</p>
<p>The <a class="el" href="classMinorCPU.html#a3be25c3c186725a89239c012fd66a987" title="Thread activation interface from BaseCPU.">MinorCPU::activateContext</a> and <a class="el" href="classMinorCPU.html#abe5185b5171ebbfb854bec4aee9163e2">MinorCPU::suspendContext</a> interface can be called to start and pause threads (threads in the MT sense) and to start and pause the pipeline. Executing instructions can call this interface (indirectly through the <a class="el" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside...">ThreadContext</a>) to idle the CPU/their threads.</p>
<h3><a class="anchor" id="stages">
Each pipeline stage</a></h3>
<p>In general, the behaviour of a stage (each cycle) is:</p>
<div class="fragment"><pre class="fragment">
    evaluate:
        push input to inputBuffer
        setup references to input/output data slots

        do 'every cycle' 'step' tasks

        if there is input and there is space in the next stage:
            process and generate a new output
            maybe re-activate the stage

        send backwards data

        if the stage generated output to the following FIFO:
            signal pipe activity

        if the stage has more processable input and space in the next stage:
            re-activate the stage for the next cycle

        commit the push to the inputBuffer if that data hasn't all been used
</pre></div><p>The <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> stage differs from this model as its forward output (branch) data is unconditionally sent to <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>. To allow this behaviour, <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> must be unconditionally receptive to that data.</p>
<h3><a class="anchor" id="fetch1">
Fetch1 stage</a></h3>
<p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> is responsible for fetching cache lines or partial cache lines from the I-cache and passing them on to <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> to be decomposed into instructions. It can receive 'change of stream' indications from both <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> to signal that it should change its internal fetch address and tag newly fetched lines with new stream or prediction sequence numbers. When both <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> signal changes of stream at the same time, <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> takes Execute's change.</p>
<p>Every line issued by <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> will bear a unique line sequence number which can be used for debugging stream changes.</p>
<p>When fetching from the I-cache, <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> will ask for data from the current fetch address (<a class="el" href="classMinor_1_1Fetch1.html#a68cc41950d48d4da37da2960f973011a" title="Fetch PC value.">Fetch1::pc</a>) up to the end of the 'data snap' size set in the parameter fetch1LineSnapWidth. Subsequent autonomous line fetches will fetch whole lines at a snap boundary and of size fetch1LineWidth.</p>
<p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> will only initiate a memory fetch if it can reserve space in <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> input buffer. That input buffer serves an the fetch queue/LFL for the system.</p>
<p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> contains two queues: requests and transfers to handle the stages of translating the address of a line fetch (via the TLB) and accommodating the request/response of fetches to/from memory.</p>
<p>Fetch requests from <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> are pushed into the requests queue as newly allocated FetchRequest objects once they have been sent to the ITLB with a call to itb-&gt;translateTiming.</p>
<p>A response from the TLB moves the request from the requests queue to the transfers queue. If there is more than one entry in each queue, it is possible to get a TLB response for request which is not at the head of the requests queue. In that case, the TLB response is marked up as a state change to Translated in the request object, and advancing the request to transfers (and the memory system) is left to calls to <a class="el" href="classMinor_1_1Fetch1.html#ac143710b93ec9f55bfc3e2882ef2fe4c" title="Step requests along between requests and transfers queues.">Fetch1::stepQueues</a> which is called in the cycle following any event is received.</p>
<p><a class="el" href="classMinor_1_1Fetch1.html#a9ace21e8131caf360190ea876cfa2934" title="Try and issue a fetch for a translated request at the head of the requests queue...">Fetch1::tryToSendToTransfers</a> is responsible for moving requests between the two queues and issuing requests to memory. Failed TLB lookups (prefetch aborts) continue to occupy space in the queues until they are recovered at the head of transfers.</p>
<p>Responses from memory change the request object state to Complete and <a class="el" href="classMinor_1_1Fetch1.html#a68a0a88ce6ee3dd170c977318cfb4ca9" title="Pass on input/buffer data to the output if you can.">Fetch1::evaluate</a> can pick up response data, package it in the <a class="el" href="classMinor_1_1ForwardLineData.html" title="Line fetch data in the forward direction.">ForwardLineData</a> object, and forward it to <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>'s input buffer.</p>
<p>As space is always reserved in <a class="el" href="classMinor_1_1Fetch2.html#a24935a6489b5988d1f3d128c1b4a685d">Fetch2::inputBuffer</a>, setting the input buffer's size to 1 results in non-prefetching behaviour.</p>
<p>When a change of stream occurs, translated requests queue members and completed transfers queue members can be unconditionally discarded to make way for new transfers.</p>
<h3><a class="anchor" id="fetch2">
Fetch2 stage</a></h3>
<p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> receives a line from <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> into its input buffer. The data in the head line in that buffer is iterated over and separated into individual instructions which are packed into a vector of instructions which can be passed to <a class="el" href="classMinor_1_1Decode.html">Decode</a>. Packing instructions can be aborted early if a fault is found in either the input line as a whole or a decomposed instruction.</p>
<h4><a class="anchor" id="bp">
Branch prediction</a></h4>
<p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> contains the branch prediction mechanism. This is a wrapper around the branch predictor interface provided by gem5 (cpu/pred/...).</p>
<p>Branches are predicted for any control instructions found. If prediction is attempted for an instruction, the <a class="el" href="classMinor_1_1MinorDynInst.html#a905b0516019ae7f47b5795ceda33f5cd" title="Tried to predict the destination of this inst (if a control instruction or a sys...">MinorDynInst::triedToPredict</a> flag is set on that instruction.</p>
<p>When a branch is predicted to take, the <a class="el" href="classMinor_1_1MinorDynInst.html#aa57659ef9d30162ddcf10fcb0f3963ac" title="This instruction was predicted to change control flow and the following instructions...">MinorDynInst::predictedTaken</a> flag is set and <a class="el" href="classMinor_1_1MinorDynInst.html#a5eaf9547bcaefa2c0fd37f32c828691b" title="Predicted branch target.">MinorDynInst::predictedTarget</a> is set to the predicted target PC value. The predicted branch instruction is then packed into <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>'s output vector, the prediction sequence number is incremented, and the branch is communicated to <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a>.</p>
<p>After signalling a prediction, <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> will discard its input buffer contents and will reject any new lines which have the same stream sequence number as that branch but have a different prediction sequence number. This allows following sequentially fetched lines to be rejected without ignoring new lines generated by a change of stream indicated from a 'real' branch from <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> (which will have a new stream sequence number).</p>
<p>The program counter value provided to <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> by <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> packets is only updated when there is a change of stream. <a class="el" href="classMinor_1_1Fetch2.html#ab4132f5b28c004edba5586823391368b" title="PC is currently valid.">Fetch2::havePC</a> indicates whether the PC will be picked up from the next processed input line. <a class="el" href="classMinor_1_1Fetch2.html#ab4132f5b28c004edba5586823391368b" title="PC is currently valid.">Fetch2::havePC</a> is necessary to allow line-wrapping instructions to be tracked through decode.</p>
<p>Branches (and instructions predicted to branch) which are processed by <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> will generate <a class="el" href="classMinor_1_1BranchData.html" title="Forward data betwen Execute and Fetch1 carrying change-of-address/stream information...">BranchData</a> (<a class="el" href="pipe__data_8hh.html" title="Contains class definitions for data flowing between pipeline stages in the top-level...">pipe_data.hh</a>) data explaining the outcome of the branch which is sent forwards to <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>. <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> uses this data to change stream (and update its stream sequence number and address for new lines). <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> uses it to update the branch predictor. <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> does not communicate branch data to the branch predictor for instructions which are discarded on the way to commit.</p>
<p>BranchData::BranchReason (<a class="el" href="pipe__data_8hh.html" title="Contains class definitions for data flowing between pipeline stages in the top-level...">pipe_data.hh</a>) encodes the possible branch scenarios:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p>Branch enum val. </p>
</td><td><p>In <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> reaction </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> reaction  </p>
</td></tr>
<tr>
<td><p>NoBranch </p>
</td><td><p>(output bubble data) </p>
</td><td><p>- </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p>CorrectlyPredictedBranch </p>
</td><td><p>Predicted, taken </p>
</td><td><p>- </p>
</td><td><p>Update BP as taken branch  </p>
</td></tr>
<tr>
<td><p>UnpredictedBranch </p>
</td><td><p>Not predicted, taken and was taken </p>
</td><td><p>New stream </p>
</td><td><p>Update BP as taken branch  </p>
</td></tr>
<tr>
<td><p>BadlyPredictedBranch </p>
</td><td><p>Predicted, not taken </p>
</td><td><p>New stream to restore to old inst. source </p>
</td><td><p>Update BP as not taken branch  </p>
</td></tr>
<tr>
<td><p>BadlyPredictedBranchTarget </p>
</td><td><p>Predicted, taken, but to a different target than predicted one </p>
</td><td><p>New stream </p>
</td><td><p>Update BTB to new target  </p>
</td></tr>
<tr>
<td><p>SuspendThread </p>
</td><td><p>Hint to suspend fetching </p>
</td><td><p>Suspend fetch for this thread (branch to next inst. as wakeup fetch addr) </p>
</td><td><p>-  </p>
</td></tr>
<tr>
<td><p>Interrupt </p>
</td><td><p>Interrupt detected </p>
</td><td><p>New stream </p>
</td><td><p>-  </p>
</td></tr>
</table>
<p>The parameter decodeInputWidth sets the number of instructions which can be packed into the output per cycle. If the parameter fetch2CycleInput is true, <a class="el" href="classMinor_1_1Decode.html">Decode</a> can try to take instructions from more than one entry in its input buffer per cycle.</p>
<h3><a class="anchor" id="decode">
Decode stage</a></h3>
<p><a class="el" href="classMinor_1_1Decode.html">Decode</a> takes a vector of instructions from <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> (via its input buffer) and decomposes those instructions into micro-ops (if necessary) and packs them into its output instruction vector.</p>
<p>The parameter executeInputWidth sets the number of instructions which can be packed into the output per cycle. If the parameter decodeCycleInput is true, <a class="el" href="classMinor_1_1Decode.html">Decode</a> can try to take instructions from more than one entry in its input buffer per cycle.</p>
<h3><a class="anchor" id="execute">
Execute stage</a></h3>
<p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> provides all the instruction execution and memory access mechanisms. An instructions passage through <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> can take multiple cycles with its precise timing modelled by a functional unit pipeline FIFO.</p>
<p>A vector of instructions (possibly including fault 'instructions') is provided to <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> by <a class="el" href="classMinor_1_1Decode.html">Decode</a> and can be queued in the <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> input buffer before being issued. Setting the parameter executeCycleInput allows execute to examine more than one input buffer entry (more than one instruction vector). The number of instructions in the input vector can be set with executeInputWidth and the depth of the input buffer can be set with parameter executeInputBufferSize.</p>
<h4><a class="anchor" id="fus">
Functional units</a></h4>
<p>The <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> stage contains pipelines for each functional unit comprising the computational core of the CPU. Functional units are configured via the executeFuncUnits parameter. Each functional unit has a number of instruction classes it supports, a stated delay between instruction issues, and a delay from instruction issue to (possible) commit and an optional timing annotation capable of more complicated timing.</p>
<p>Each active cycle, <a class="el" href="classMinor_1_1Execute.html#a2d6ca9a694bf99ef82da7759cba8c3da" title="Pass on input/buffer data to the output if you can.">Execute::evaluate</a> performs this action:</p>
<div class="fragment"><pre class="fragment">
    Execute::evaluate:
        push input to inputBuffer
        setup references to input/output data slots and branch output slot

        step D-cache interface queues (similar to Fetch1)

        if interrupt posted:
            take interrupt (signalling branch to Fetch1/Fetch2)
        else
            commit instructions
            issue new instructions

        advance functional unit pipelines

        reactivate Execute if the unit is still active

        commit the push to the inputBuffer if that data hasn't all been used
</pre></div><h4><a class="anchor" id="fifos">
Functional unit FIFOs</a></h4>
<p>Functional units are implemented as SelfStallingPipelines (stage.hh). These are <a class="el" href="classTimeBuffer.html">TimeBuffer</a> FIFOs with two distinct 'push' and 'pop' wires. They respond to <a class="el" href="classMinor_1_1SelfStallingPipeline.html#ad933640bc6aab559c009302e478c3768" title="Try to advance the pipeline.">SelfStallingPipeline::advance</a> in the same way as TimeBuffers <b>unless</b> there is data at the far, 'pop', end of the FIFO. A 'stalled' flag is provided for signalling stalling and to allow a stall to be cleared. The intention is to provide a pipeline for each functional unit which will never advance an instruction out of that pipeline until it has been processed and the pipeline is explicitly unstalled.</p>
<p>The actions 'issue', 'commit', and 'advance' act on the functional units.</p>
<h4><a class="anchor" id="issue">
Issue</a></h4>
<p>Issuing instructions involves iterating over both the input buffer instructions and the heads of the functional units to try and issue instructions in order. The number of instructions which can be issued each cycle is limited by the parameter executeIssueLimit, how executeCycleInput is set, the availability of pipeline space and the policy used to choose a pipeline in which the instruction can be issued.</p>
<p>At present, the only issue policy is strict round-robin visiting of each pipeline with the given instructions in sequence. For greater flexibility, better (and more specific policies) will need to be possible.</p>
<p>Memory operation instructions traverse their functional units to perform their EA calculations. On 'commit', the ExecContext::initiateAcc execution phase is performed and any memory access is issued (via. <a class="el" href="classMinor_1_1ExecContext.html" title="ExecContext bears the exec_context interface for Minor.">ExecContext</a>::{read,write}Mem calling <a class="el" href="classMinor_1_1LSQ.html#a44c53b80475589d1128435890dc947d0" title="Single interface for readMem/writeMem to issue requests into the LSQ.">LSQ::pushRequest</a>) to the <a class="el" href="classMinor_1_1LSQ.html">LSQ</a>.</p>
<p>Note that faults are issued as if they are instructions and can (currently) be issued to *any* functional unit.</p>
<p>Every issued instruction is also pushed into the <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> queue. Memory ref. instructions are pushing into <a class="el" href="classMinor_1_1Execute.html#a388070f2745311d280b6f0dd46bbd7a2" title="Memory ref instructions still in the FUs.">Execute::inFUMemInsts</a> queue.</p>
<h4><a class="anchor" id="commit">
Commit</a></h4>
<p>Instructions are committed by examining the head of the <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> queue (which is decorated with the functional unit number to which the instruction was issued). Instructions which can then be found in their functional units are executed and popped from <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a>.</p>
<p>Memory operation instructions are committed into the memory queues (as described above) and exit their functional unit pipeline but are not popped from the <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> queue. The <a class="el" href="classMinor_1_1Execute.html#a388070f2745311d280b6f0dd46bbd7a2" title="Memory ref instructions still in the FUs.">Execute::inFUMemInsts</a> queue provides ordering to memory operations as they pass through the functional units (maintaining issue order). On entering the <a class="el" href="classMinor_1_1LSQ.html">LSQ</a>, instructions are popped from <a class="el" href="classMinor_1_1Execute.html#a388070f2745311d280b6f0dd46bbd7a2" title="Memory ref instructions still in the FUs.">Execute::inFUMemInsts</a>.</p>
<p>If the parameter executeAllowEarlyMemoryIssue is set, memory operations can be sent from their FU to the <a class="el" href="classMinor_1_1LSQ.html">LSQ</a> before reaching the head of <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> but after their dependencies are met. <a class="el" href="classMinor_1_1MinorDynInst.html#ac72a9dcff570bbaf24da9ee74392e6d0" title="execSeqNum of the latest inst on which this inst depends.">MinorDynInst::instToWaitFor</a> is marked up with the latest dependent instruction execSeqNum required to be committed for a memory operation to progress to the <a class="el" href="classMinor_1_1LSQ.html">LSQ</a>.</p>
<p>Once a memory response is available (by testing the head of <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> against <a class="el" href="classMinor_1_1LSQ.html#a458abe5d220a0f66600bf339bceb2100" title="Returns a response if it&#39;s at the head of the transfers queue and it&#39;s either...">LSQ::findResponse</a>), commit will process that response (ExecContext::completeAcc) and pop the instruction from <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a>.</p>
<p>Any branch, fault or interrupt will cause a stream sequence number change and signal a branch to Fetch1/Fetch2. Only instructions with the current stream sequence number will be issued and/or committed.</p>
<h4><a class="anchor" id="advance">
Advance</a></h4>
<p>All non-stalled pipeline are advanced and may, thereafter, become stalled. Potential activity in the next cycle is signalled if there are any instructions remaining in any pipeline.</p>
<h4><a class="anchor" id="sb">
Scoreboard</a></h4>
<p>The scoreboard (<a class="el" href="classMinor_1_1Scoreboard.html" title="A scoreboard of register dependencies including, for each register: The number of...">Scoreboard</a>) is used to control instruction issue. It contains a count of the number of in flight instructions which will write each general purpose CPU integer or float register. Instructions will only be issued where the scoreboard contains a count of 0 instructions which will write to one of the instructions source registers.</p>
<p>Once an instruction is issued, the scoreboard counts for each destination register for an instruction will be incremented.</p>
<p>The estimated delivery time of the instruction's result is marked up in the scoreboard by adding the length of the issued-to FU to the current time. The timings parameter on each FU provides a list of additional rules for calculating the delivery time. These are documented in the parameter comments in MinorCPU.py.</p>
<p>On commit, (for memory operations, memory response commit) the scoreboard counters for an instruction's source registers are decremented. will be decremented.</p>
<h4><a class="anchor" id="ifi">
Execute::inFlightInsts</a></h4>
<p>The <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> queue will always contain all instructions in flight in <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> in the correct issue order. <a class="el" href="classMinor_1_1Execute.html#a47beeefedd4e2aef21670fc2e0eda21b" title="Try and issue instructions from the inputBuffer.">Execute::issue</a> is the only process which will push an instruction into the queue. <a class="el" href="classMinor_1_1Execute.html#af28d1ce28bef0b371e268438bf0d3f02" title="Try and commit instructions from the ends of the functional unit pipelines.">Execute::commit</a> is the only process that can pop an instruction.</p>
<h4><a class="anchor" id="lsq">
LSQ</a></h4>
<p>The <a class="el" href="classMinor_1_1LSQ.html">LSQ</a> can support multiple outstanding transactions to memory in a number of conservative cases.</p>
<p>There are three queues to contain requests: requests, transfers and the store buffer. The requests and transfers queue operate in a similar manner to the queues in <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a>. The store buffer is used to decouple the delay of completing store operations from following loads.</p>
<p>Requests are issued to the DTLB as their instructions leave their functional unit. At the head of requests, cacheable load requests can be sent to memory and on to the transfers queue. Cacheable stores will be passed to transfers unprocessed and progress that queue maintaining order with other transactions.</p>
<p>The conditions in <a class="el" href="classMinor_1_1LSQ.html#a7d7b8ddc7c69fd9eb3b8594fe261d8e8" title="Try and issue a memory access for a translated request at the head of the requests...">LSQ::tryToSendToTransfers</a> dictate when requests can be sent to memory.</p>
<p>All uncacheable transactions, split transactions and locked transactions are processed in order at the head of requests. Additionally, store results residing in the store buffer can have their data forwarded to cacheable loads (removing the need to perform a read from memory) but no cacheable load can be issue to the transfers queue until that queue's stores have drained into the store buffer.</p>
<p>At the end of transfers, requests which are <a class="el" href="classMinor_1_1LSQ_1_1LSQRequest.html#a429d50f5dd6be4217d5dba93f8c289d3a81b9dbf6670e396d0266949d59b57428">LSQ::LSQRequest::Complete</a> (are faulting, are cacheable stores, or have been sent to memory and received a response) can be picked off by <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> and either committed (ExecContext::completeAcc) and, for stores, be sent to the store buffer.</p>
<p><a class="el" href="classBarrier.html">Barrier</a> instructions do not prevent cacheable loads from progressing to memory but do cause a stream change which will discard that load. Stores will not be committed to the store buffer if they are in the shadow of the barrier but before the new instruction stream has arrived at <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a>. As all other memory transactions are delayed at the end of the requests queue until they are at the head of <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a>, they will be discarded by any barrier stream change.</p>
<p>After commit, <a class="el" href="classMinor_1_1LSQ_1_1BarrierDataRequest.html" title="Request for doing barrier accounting in the store buffer.">LSQ::BarrierDataRequest</a> requests are inserted into the store buffer to track each barrier until all preceding memory transactions have drained from the store buffer. No further memory transactions will be issued from the ends of FUs until after the barrier has drained.</p>
<h4><a class="anchor" id="drain">
Draining</a></h4>
<p>Draining is mostly handled by the <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> stage. When initiated by calling <a class="el" href="classMinorCPU.html#afc33a6d7193a7109308855d6140a8371" title="Drain interface.">MinorCPU::drain</a>, <a class="el" href="classMinor_1_1Pipeline.html#aa73853210f59f6d9cd217da138de390d" title="A custom evaluate allows report in the right place (between stages and pipeline advance)...">Pipeline::evaluate</a> checks the draining status of each unit each cycle and keeps the pipeline active until draining is complete. It is <a class="el" href="classMinor_1_1Pipeline.html" title="The constructed pipeline.">Pipeline</a> that signals the completion of draining. <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> is triggered by <a class="el" href="classMinorCPU.html#afc33a6d7193a7109308855d6140a8371" title="Drain interface.">MinorCPU::drain</a> and starts stepping through its <a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40" title="Stage cycle-by-cycle state.">Execute::DrainState</a> state machine, starting from state <a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40aeecf47987ef0d4aa0a6a59403d085ec9">Execute::NotDraining</a>, in this order:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b>State</b> </p>
</td><td><p><b>Meaning</b>  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40aeecf47987ef0d4aa0a6a59403d085ec9">Execute::NotDraining</a> </p>
</td><td><p>Not trying to drain, normal execution  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40aec53785380b6256e2baa889739311570">Execute::DrainCurrentInst</a> </p>
</td><td><p>Draining micro-ops to complete inst.  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40a516d421a79c458d376bedeb067fc207f">Execute::DrainHaltFetch</a> </p>
</td><td><p>Halt fetching instructions  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40ade3ca2567fed8d893896d71bb95f13ca">Execute::DrainAllInsts</a> </p>
</td><td><p>Discarding all instructions presented  </p>
</td></tr>
</table>
<p>When complete, a drained <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> unit will be in the <a class="el" href="classMinor_1_1Execute.html#aeb21dbbbbde40d8cdc68e9b17ddd3d40ade3ca2567fed8d893896d71bb95f13ca">Execute::DrainAllInsts</a> state where it will continue to discard instructions but has no knowledge of the drained state of the rest of the model.</p>
<h2><a class="anchor" id="debug">
Debug options</a></h2>
<p>The model provides a number of debug flags which can be passed to gem5 with the --debug-flags option.</p>
<p>The available flags are:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b><a class="el" href="namespaceDebug.html">Debug</a> flag</b> </p>
</td><td><p><b>Unit which will generate debugging output</b>  </p>
</td></tr>
<tr>
<td><p>Activity </p>
</td><td><p><a class="el" href="namespaceDebug.html">Debug</a> ActivityMonitor actions  </p>
</td></tr>
<tr>
<td><p>Branch </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> and <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> branch prediction decisions  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinorCPU.html" title="MinorCPU is an in-order CPU model with four fixed pipeline stages:.">MinorCPU</a> </p>
</td><td><p>CPU global actions such as wakeup/thread suspension  </p>
</td></tr>
<tr>
<td><p><a class="el" href="classMinor_1_1Decode.html">Decode</a> </p>
</td><td><p><a class="el" href="classMinor_1_1Decode.html">Decode</a>  </p>
</td></tr>
<tr>
<td><p>MinorExec </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> behaviour  </p>
</td></tr>
<tr>
<td><p>Fetch </p>
</td><td><p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>  </p>
</td></tr>
<tr>
<td><p>MinorInterrupt </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> interrupt handling  </p>
</td></tr>
<tr>
<td><p>MinorMem </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> memory interactions  </p>
</td></tr>
<tr>
<td><p>MinorScoreboard </p>
</td><td><p><a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> scoreboard activity  </p>
</td></tr>
<tr>
<td><p>MinorTrace </p>
</td><td><p>Generate MinorTrace cyclic state trace output (see below)  </p>
</td></tr>
<tr>
<td><p>MinorTiming </p>
</td><td><p>MinorTiming instruction timing modification operations  </p>
</td></tr>
</table>
<p>The group flag <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a> enables all of the flags beginning with <a class="el" href="namespaceMinor.html" title="Minor contains all the definitions within the MinorCPU apart from the CPU class itself...">Minor</a>.</p>
<h2><a class="anchor" id="trace">
MinorTrace and minorview.py</a></h2>
<p>The debug flag MinorTrace causes cycle-by-cycle state data to be printed which can then be processed and viewed by the minorview.py tool. This output is very verbose and so it is recommended it only be used for small examples.</p>
<h3><a class="anchor" id="traceformat">
MinorTrace format</a></h3>
<p>There are three types of line outputted by MinorTrace:</p>
<h4><a class="anchor" id="state">
MinorTrace - Ticked unit cycle state</a></h4>
<p>For example:</p>
<div class="fragment"><pre class="fragment">
 110000: system.cpu.dcachePort: MinorTrace: state=MemoryRunning in_tlb_mem=0/0
</pre></div><p>For each time step, the MinorTrace flag will cause one MinorTrace line to be printed for every named element in the model.</p>
<h4><a class="anchor" id="traceunit">
MinorInst - summaries of instructions issued by     Decode</a></h4>
<p><a class="el" href="classMinor_1_1Decode.html">Decode</a></p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">
 140000: system.cpu.execute: MinorInst: id=0/1.1/1/1.1 addr=0x5c \
                             inst="  mov r0, #0" class=IntAlu
</pre></div><p>MinorInst lines are currently only generated for instructions which are committed.</p>
<h4><a class="anchor" id="tracefetch1">
MinorLine - summaries of line fetches issued by     Fetch1</a></h4>
<p><a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a></p>
<p>For example:</p>
<div class="fragment"><pre class="fragment">
  92000: system.cpu.icachePort: MinorLine: id=0/1.1/1 size=36 \
                                vaddr=0x5c paddr=0x5c
</pre></div><h3><a class="anchor" id="minorview">
minorview.py</a></h3>
<p>Minorview (util/minorview.py) can be used to visualise the data created by MinorTrace.</p>
<div class="fragment"><pre class="fragment">
usage: minorview.py [-h] [--picture picture-file] [--prefix name]
                   [--start-time time] [--end-time time] [--mini-views]
                   event-file

Minor visualiser

positional arguments:
  event-file

optional arguments:
  -h, --help            show this help message and exit
  --picture picture-file
                        markup file containing blob information (default:
                        &lt;minorview-path&gt;/minor.pic)
  --prefix name         name prefix in trace for CPU to be visualised
                        (default: system.cpu)
  --start-time time     time of first event to load from file
  --end-time time       time of last event to load from file
  --mini-views          show tiny views of the next 10 time steps
</pre></div><p>Raw debugging output can be passed to minorview.py as the event-file. It will pick out the MinorTrace lines and use other lines where units in the simulation are named (such as system.cpu.dcachePort in the above example) will appear as 'comments' when units are clicked on the visualiser.</p>
<p>Clicking on a unit which contains instructions or lines will bring up a speech bubble giving extra information derived from the MinorInst/MinorLine lines.</p>
<p>--start-time and --end-time allow only sections of debug files to be loaded.</p>
<p>--prefix allows the name prefix of the CPU to be inspected to be supplied. This defaults to 'system.cpu'.</p>
<p>In the visualiser, The buttons Start, End, Back, Forward, Play and Stop can be used to control the displayed simulation time.</p>
<p>The diagonally striped coloured blocks are showing the <a class="el" href="classMinor_1_1InstId.html" title="Id for lines and instructions.">InstId</a> of the instruction or line they represent. Note that lines in <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> and f1ToF2.F only show the id fields of a line and that instructions in <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a>, f2ToD, and decode.inputBuffer do not yet have execute sequence numbers. The T/S.P/L/F.E buttons can be used to toggle parts of <a class="el" href="classMinor_1_1InstId.html" title="Id for lines and instructions.">InstId</a> on and off to make it easier to understand the display. Useful combinations are:</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b>Combination</b> </p>
</td><td><p><b>Reason</b>  </p>
</td></tr>
<tr>
<td><p>E </p>
</td><td><p>just show the final execute sequence number  </p>
</td></tr>
<tr>
<td><p>F/E </p>
</td><td><p>show the instruction-related numbers  </p>
</td></tr>
<tr>
<td><p>S/P </p>
</td><td><p>show just the stream-related numbers (watch the stream sequence change with branches and not change with predicted branches)  </p>
</td></tr>
<tr>
<td><p>S/E </p>
</td><td><p>show instructions and their stream  </p>
</td></tr>
</table>
<p>The key to the right shows all the displayable colours (some of the colour choices are quite bad!):</p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><p><b>Symbol</b> </p>
</td><td><p><b>Meaning</b>  </p>
</td></tr>
<tr>
<td><p>U </p>
</td><td><p>Unknown data  </p>
</td></tr>
<tr>
<td><p>B </p>
</td><td><p>Blocked stage  </p>
</td></tr>
<tr>
<td><p>- </p>
</td><td><p>Bubble  </p>
</td></tr>
<tr>
<td><p>E </p>
</td><td><p>Empty queue slot  </p>
</td></tr>
<tr>
<td><p>R </p>
</td><td><p>Reserved queue slot  </p>
</td></tr>
<tr>
<td><p>F </p>
</td><td><p>Fault  </p>
</td></tr>
<tr>
<td><p>r </p>
</td><td><p>Read (used as the leftmost stripe on data in the dcachePort)  </p>
</td></tr>
<tr>
<td><p>w </p>
</td><td><p>Write " "  </p>
</td></tr>
<tr>
<td><p>0 to 9 </p>
</td><td><p>last decimal digit of the corresponding data  </p>
</td></tr>
</table>
<div class="fragment"><pre class="fragment">

    ,---------------.         .--------------.  *U
    | |=|-&gt;|=|-&gt;|=| |         ||=|||-&gt;||-&gt;|| |  *-  &lt;- Fetch queues/LSQ
    `---------------'         `--------------'  *R
    === ======                                  *w  &lt;- Activity/Stage activity
                              ,--------------.  *1
    ,--.      ,.      ,.      | ============ |  *3  &lt;- Scoreboard
    |  |-\[]-\||-\[]-\||-\[]-\| ============ |  *5  &lt;- Execute::inFlightInsts
    |  | :[] :||-/[]-/||-/[]-/| -. --------  |  *7
    |  |-/[]-/||  ^   ||      |  | --------- |  *9
    |  |      ||  |   ||      |  | ------    |
[]-&gt;|  |    -&gt;||  |   ||      |  | ----      |
    |  |&lt;-[]&lt;-||&lt;-+-&lt;-||&lt;-[]&lt;-|  | ------    |-&gt;[] &lt;- Execute to Fetch1,
    '--`      `'  ^   `'      | -' ------    |        Fetch2 branch data
             ---. |  ---.     `--------------'
             ---' |  ---'       ^       ^
                  |   ^         |       `------------ Execute
  MinorBuffer ----' input       `-------------------- Execute input buffer
                    buffer
</pre></div><p>Stages show the colours of the instructions currently being generated/processed.</p>
<p>Forward FIFOs between stages show the data being pushed into them at the current tick (to the left), the data in transit, and the data available at their outputs (to the right).</p>
<p>The backwards FIFO between <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> and <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> shows branch prediction data.</p>
<p>In general, all displayed data is correct at the end of a cycle's activity at the time indicated but before the inter-stage FIFOs are ticked. Each FIFO has, therefore an extra slot to show the asserted new input data, and all the data currently within the FIFO.</p>
<p>Input buffers for each stage are shown below the corresponding stage and show the contents of those buffers as horizontal strips. Strips marked as reserved (cyan by default) are reserved to be filled by the previous stage. An input buffer with all reserved or occupied slots will, therefore, block the previous stage from generating output.</p>
<p>Fetch queues and <a class="el" href="classMinor_1_1LSQ.html">LSQ</a> show the lines/instructions in the queues of each interface and show the number of lines/instructions in TLB and memory in the two striped colours of the top of their frames.</p>
<p>Inside <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a>, the horizontal bars represent the individual FU pipelines. The vertical bar to the left is the input buffer and the bar to the right, the instructions committed this cycle. The background of <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> shows instructions which are being committed this cycle in their original FU pipeline positions.</p>
<p>The strip at the top of the <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> block shows the current streamSeqNum that <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> is committing. A similar stripe at the top of <a class="el" href="classMinor_1_1Fetch1.html" title="A stage responsible for fetching &quot;lines&quot; from memory and passing them to...">Fetch1</a> shows that stage's expected streamSeqNum and the stripe at the top of <a class="el" href="classMinor_1_1Fetch2.html" title="This stage receives lines of data from Fetch1, separates them into instructions and...">Fetch2</a> shows its issuing predictionSeqNum.</p>
<p>The scoreboard shows the number of instructions in flight which will commit a result to the register in the position shown. The scoreboard contains slots for each integer and floating point register.</p>
<p>The <a class="el" href="classMinor_1_1Execute.html#a7cf528e6941d6859365461329dd247f1" title="In-order instructions either in FUs or the LSQ.">Execute::inFlightInsts</a> queue shows all the instructions in flight in <a class="el" href="classMinor_1_1Execute.html" title="Execute stage.">Execute</a> with the oldest instruction (the next instruction to be committed) to the right.</p>
<p>'Stage activity' shows the signalled activity (as E/1) for each stage (with CPU miscellaneous activity to the left)</p>
<p>'Activity' show a count of stage and pipe activity.</p>
<h3><a class="anchor" id="picformat">
minor.pic format</a></h3>
<p>The minor.pic file (src/minor/minor.pic) describes the layout of the models blocks on the visualiser. Its format is described in the supplied minor.pic file. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Mon Dec 7 02:33:14 2015 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.6.1</small></address>

</body>
</html>
