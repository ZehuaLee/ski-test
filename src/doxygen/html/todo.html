<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="todo">Todo List </a></h1><p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>Member <a class="el" href="classArmISA_1_1TableWalker.html#a6a5556160487c183ab7c8e3c0fea95e4">ArmISA::TableWalker::doL1Descriptor</a> () </dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l1.Desc.setAp0() instead of generating AccessFlag0 </dd>
</dl>
<p><a class="anchor" id="_todo000004"></a> </p>
<dl>
<dt>Member <a class="el" href="classArmISA_1_1TableWalker.html#aa10ffa418815a92e2a26e9a8bfea2251">ArmISA::TableWalker::doL2Descriptor</a> () </dt>
<dd>: check sctlr.ha (bit[17]) if Hardware Access Flag is enabled if set, do l2.Desc.setAp0() instead of generating AccessFlag0 </dd>
</dl>
<p><a class="anchor" id="_todo000002"></a> </p>
<dl>
<dt>Member <a class="el" href="classArmISA_1_1TableWalker.html#a99384dd8d969f217c011ec84bfcaac4d">ArmISA::TableWalker::walk</a> (RequestPtr req, <a class="el" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside...">ThreadContext</a> *tc, uint16_t asid, uint8_t _vmid, bool _isHyp, TLB::Mode mode, TLB::Translation *_trans, bool timing, bool functional, bool secure, TLB::ArmTranslationType tranType) </dt>
<dd>These should be cached or grabbed from cached copies in the TLB, all these miscreg reads are expensive </dd>
</dl>
<p><a class="anchor" id="_todo000011"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseDynInst.html#afd5a603ab953f075866e3586cdcf7a4f">BaseDynInst::_readySrcRegIdx</a>  </dt>
<dd>: Not sure this should be here vs the derived class. </dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseDynInst.html#a47f19df85729fed56c10a6f5bb605c6e">BaseDynInst::doneTargCalc</a> () </dt>
<dd>: Actually use this instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseDynInst.html#a77b6c82a788d8918210e90bd4e20de35a8439934599b394ff1c476242c1ed5bac">BaseDynInst::EACalcDone</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseDynInst.html#a0b411996799e93481d2b08b1410ff38e">BaseDynInst::instEffAddr</a>  </dt>
<dd>: Consider if this is necessary or not. </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseDynInst.html#aebee4ac4b0b27c4a64d68237f0e56480">BaseDynInst::renameSrcReg</a> (int idx, PhysRegIndex renamed_src) </dt>
<dd>: add in whether or not the source register is ready. </dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseO3DynInst.html#a2bed1bdf8b73b065810ee0da50a8018b">BaseO3DynInst::setIntRegOperand</a> (const <a class="el" href="classStaticInst.html" title="Base, ISA-independent static instruction class.">StaticInst</a> *si, int idx, IntReg val) </dt>
<dd>: Make results into arrays so they can handle multiple dest registers. </dd>
</dl>
<p><a class="anchor" id="_todo000061"></a> </p>
<dl>
<dt>Member <a class="el" href="classBaseSetAssoc.html#adb9589eab5811c4eb21652028983da60">BaseSetAssoc::BaseSetAssoc</a> (const Params *p) </dt>
<dd>Make warmup percentage a parameter. </dd>
</dl>
<p><a class="anchor" id="_todo000060"></a> </p>
<dl>
<dt>Member <a class="el" href="group__CacheStatistics.html#gac2d470873ac9233dca52ac3701aded6f">BaseTags::avgRefs</a>  </dt>
<dd>This should change to an average stat once we have them. </dd>
</dl>
<p><a class="anchor" id="_todo000031"></a> </p>
<dl>
<dt>Member <a class="el" href="classBPredUnit.html#adc5b6e32f6abcf244f12339eae791ba5">BPredUnit::update</a> (Addr instPC, bool taken, void *bp_history, bool squashed)=0 </dt>
<dd>Make this update flexible enough to handle a global predictor. </dd>
</dl>
<p><a class="anchor" id="_todo000056"></a> </p>
<dl>
<dt>Member <a class="el" href="classCache.html#ad60e304291a4a70aa915f8cf8f5df538">Cache::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000057"></a> </p>
<dl>
<dt>Member <a class="el" href="classCache.html#a9f7dbd529751ff1574fe4db7f644bbb7">Cache::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd><p class="startdd">temporary hack to deal with memory corruption issue until 4-phase transactions are complete </p>
<p>nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </p>
<p class="enddd">nominally we should just delete the packet here, however, until 4-phase stuff we can't because sending cache is still relying on it </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000055"></a> </p>
<dl>
<dt>Member <a class="el" href="classCacheBlk.html#a4a634d8c23931f3e32f318fe87df7c67">CacheBlk::set</a>  </dt>
<dd>Move this into subclasses when we fix CacheTags to use them. </dd>
</dl>
<p><a class="anchor" id="_todo000064"></a> </p>
<dl>
<dt>Member <a class="el" href="classDRAMCtrl.html#a191c65a436d32961f1e75b219da49349">DRAMCtrl::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000063"></a> </p>
<dl>
<dt>Member <a class="el" href="classDRAMCtrl.html#a54cc6c75a9f00865e829d327e68bd528">DRAMCtrl::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd>temporary hack to deal with memory corruption issues until 4-phase transactions are complete </dd>
</dl>
<p><a class="anchor" id="_todo000065"></a> </p>
<dl>
<dt>Member <a class="el" href="classDRAMSim2.html#a63b84408cc9b592d983165f8d3ac24c4">DRAMSim2::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000072"></a> </p>
<dl>
<dt>Member <a class="el" href="classEventQueue.html#a74bcdad13d45b55c9d44711e89f66e68">EventQueue::serviceEvents</a> (Tick when) </dt>
<dd>this assert is a good bug catcher. I need to make it true again. </dd>
</dl>
<p><a class="anchor" id="_todo000062"></a> </p>
<dl>
<dt>Member <a class="el" href="classFALRU.html#a8027ce1282e3c1fa9acc7e6e4765da17">FALRU::print</a> () const  </dt>
<dd>Implement as in lru. Currently not used </dd>
</dl>
<p><a class="anchor" id="_todo000017"></a> </p>
<dl>
<dt>Member <a class="el" href="classFullO3CPU.html#aec7042843f1ccda2a1e735205109d94e">FullO3CPU::syscall</a> (int64_t callnum, ThreadID tid) </dt>
<dd>: Determine if this needs to be virtual. </dd>
</dl>
<p><a class="anchor" id="_todo000039"></a> </p>
<dl>
<dt>Member <a class="el" href="classIdeDisk.html#af711fdd8150c8623e461bade7fd72f83">IdeDisk::doDmaDataRead</a> () </dt>
<dd>we need to figure out what the delay actually will be </dd>
</dl>
<p><a class="anchor" id="_todo000040"></a> </p>
<dl>
<dt>Member <a class="el" href="classIdeDisk.html#a6abe13bc348e45ae7b558295a72cd1b0">IdeDisk::doDmaDataWrite</a> () </dt>
<dd>we need to figure out what the delay actually will be </dd>
</dl>
<p><a class="anchor" id="_todo000041"></a> </p>
<dl>
<dt>Member <a class="el" href="classIdeDisk.html#aa0afc6c1b1a81cc1c6af156d0b5bd6bf">IdeDisk::startCommand</a> () </dt>
<dd>make this a scheduled event to simulate disk delay </dd>
</dl>
<p><a class="anchor" id="_todo000042"></a> </p>
<dl>
<dt>Member <a class="el" href="classIdeDisk.html#a065b7c8d6188d4bb96ec9aa3993ef3e8">IdeDisk::updateState</a> (DevAction_t action) </dt>
<dd><p class="startdd">change this to a scheduled event to simulate disk delay </p>
<p class="enddd">change this to a scheduled event to simulate disk delay </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>File <a class="el" href="inifile_8hh.html">inifile.hh</a>  </dt>
<dd>Change comments to match documentation style. </dd>
</dl>
<p><a class="anchor" id="_todo000022"></a> </p>
<dl>
<dt>Member <a class="el" href="classInstructionQueue.html#aef6f5624fc57f3ba6c9da58fae657e1c">InstructionQueue::commitToIEWDelay</a>  </dt>
<dd>: Make there be a distinction between the delays within IEW. </dd>
</dl>
<p><a class="anchor" id="_todo000021"></a> </p>
<dl>
<dt>Member <a class="el" href="classInstructionQueue.html#a1457a5c88204b676b8648d343012826c">InstructionQueue::listOrder</a>  </dt>
<dd>: Might be better to just move these entries around instead of creating new ones every time the position changes due to an instruction issuing. Not sure <a class="el" href="classstd_1_1list.html" title="STL list class.">std::list</a> supports this. </dd>
</dl>
<p><a class="anchor" id="_todo000023"></a> </p>
<dl>
<dt>Member <a class="el" href="classInstructionQueue.html#a124912debf5250a350c01f55754bfd8c">InstructionQueue::numIssuedDist</a>  </dt>
<dd>: Need to create struct to track the entry time for each instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000024"></a> </p>
<dl>
<dt>Member <a class="el" href="classInstructionQueue.html#a8a1306b0035d6377322817f4524b50d0">InstructionQueue::statFuBusy</a>  </dt>
<dd>: Need to create struct to track the ready time for each instruction. </dd>
</dl>
<p><a class="anchor" id="_todo000020"></a> </p>
<dl>
<dt>Class <a class="el" href="classInstructionQueue.html">InstructionQueue&lt; Impl &gt;</a>  </dt>
<dd>: Make IQ able to handle multiple FU pools. </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinuxAlphaSystem.html#a5e0e1b2232d67d030baeaa8a81e26eaf">LinuxAlphaSystem::initState</a> () </dt>
<dd>At some point we should change <a class="el" href="ev5_8hh.html">ev5.hh</a> and the palcode to support 255 ASNs. </dd>
</dl>
<p><a class="anchor" id="_todo000028"></a> </p>
<dl>
<dt>Member <a class="el" href="classLSQUnit.html#a19f506e75e7e2a1c493e87509b6f32f3">LSQUnit::cachePorts</a>  </dt>
<dd>Consider moving to a more advanced model with write vs read ports </dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>Member <a class="el" href="classLSQUnit.html#aa457b4404d19a29de12a870cbf61560c">LSQUnit::checkViolations</a> (int load_idx, DynInstPtr &amp;inst) </dt>
<dd>in theory you only need to check an instruction that has executed however, there isn't a good way in the pipeline at the moment to check all instructions that will execute before the store writes back. Thus, like the implementation that came before it, we're overly conservative. </dd>
</dl>
<p><a class="anchor" id="_todo000026"></a> </p>
<dl>
<dt>Member <a class="el" href="classLSQUnit.html#a6e735100c0f4c1334afff9eee21fe6d1">LSQUnit::LQEntries</a>  </dt>
<dd>: Consider having var that records the true number of LQ entries. </dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>Member <a class="el" href="classLSQUnit.html#a4741b4527dbac9ba10acd275ed43c69a">LSQUnit::SQEntries</a>  </dt>
<dd>: Consider having var that records the true number of SQ entries. </dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>Member <a class="el" href="classLSQUnit.html#a1d05844ff8e9338356a6935b604e1bad">LSQUnit::tick</a> () </dt>
<dd>: Move the number of used ports up to the <a class="el" href="classLSQ.html">LSQ</a> level so it can be shared by all <a class="el" href="classLSQ.html">LSQ</a> units. </dd>
</dl>
<p><a class="anchor" id="_todo000047"></a> </p>
<dl>
<dt>Member <a class="el" href="classMaltaPChip.html#a7a0163c8efdccbd04c9f525a90078955">MaltaPChip::translatePciToDma</a> (Addr busAddr) </dt>
<dd><p class="startdd">Andrew says this needs to be fixed. What's wrong with it? </p>
<p class="enddd">This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the malta documentation on page 10-12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000048"></a> </p>
<dl>
<dt>Member <a class="el" href="classNSGigE.html#a16a963d4924b7c2e82d338d693abe4af">NSGigE::cpuIntrPost</a> (Tick when) </dt>
<dd>this warning should be removed and the intrTick code should be fixed. </dd>
</dl>
<p><a class="anchor" id="_todo000049"></a> </p>
<dl>
<dt>Member <a class="el" href="classNSGigE.html#aec2097dcddfbd9263ce8cfd2fd11c474">NSGigE::rxKick</a> () </dt>
<dd><p class="startdd">in reality, we should be able to start processing the packet as it arrives, and not have to wait for the full packet ot be in the receive fifo. </p>
<p class="enddd">do we want to schedule a future kick? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000051"></a> </p>
<dl>
<dt>Member <a class="el" href="classNSGigE.html#ac37bda95e09a290e343ef80fc3fc9e2b">NSGigE::txKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000030"></a> </p>
<dl>
<dt>Member <a class="el" href="classO3ThreadContext.html#a5d9fb6b6d41249f8cd62e66afa2dc558">O3ThreadContext::dumpFuncProfile</a> () </dt>
<dd>: Implement. </dd>
</dl>
<p><a class="anchor" id="_todo000037"></a> </p>
<dl>
<dt>Class <a class="el" href="classPl390.html">Pl390</a>  </dt>
<dd>this code only assumes one processor for now. Low word of intEnabled and pendingInt need to be replicated per CPU. bottom 31 interrupts (7 words) need to be replicated for for interrupt priority register, processor target registers interrupt config registers </dd>
</dl>
<p><a class="anchor" id="_todo000038"></a> </p>
<dl>
<dt>Member <a class="el" href="classPl390.html#a6605185884e8b0b524d7c6f4ed3fe374">Pl390::cpuAddr</a>  </dt>
<dd>is this one per cpu? </dd>
</dl>
<p><a class="anchor" id="_todo000036"></a> </p>
<dl>
<dt>Member <a class="el" href="classPl390.html#a01024d37d71203e22b95d95974bb003d">Pl390::readDistributor</a> (PacketPtr pkt) </dt>
<dd>software generated interrutps and PPIs can't be configured in some ways </dd>
</dl>
<p><a class="anchor" id="_todo000008"></a> </p>
<dl>
<dt>Member <a class="el" href="classRefCounted.html#a5e65f84e3e6cc1c2c633b97a19d49246">RefCounted::~RefCounted</a> () </dt>
<dd>Even if this were true, does it matter? Shouldn't the derived class indicate this? This only matters if we would ever choose to delete a "RefCounted *" which I doubt we'd ever do. We don't ever delete a "void *". </dd>
</dl>
<p><a class="anchor" id="_todo000066"></a> </p>
<dl>
<dt>Member <a class="el" href="classRequest.html#a4860f73fe71baaf5b1b637207c35673c">Request::invldMasterId</a>  </dt>
<dd>C++1x replace with numeric_limits when constexpr is added </dd>
</dl>
<p><a class="anchor" id="_todo000032"></a> </p>
<dl>
<dt>Class <a class="el" href="classSatCounter.html">SatCounter</a>  </dt>
<dd>Consider making this something that more closely mimics a built in class so you can use ++ or --. </dd>
</dl>
<p><a class="anchor" id="_todo000068"></a> </p>
<dl>
<dt>Member <a class="el" href="classSimpleMemory.html#a14f6e0b5067d86bde780612b7eca6473">SimpleMemory::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches needs this packet until true is returned, so hold onto it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000067"></a> </p>
<dl>
<dt>Member <a class="el" href="classSimpleMemory.html#a8e3fd613502b7c5aad717a13c9d55e97">SimpleMemory::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd>temporary hack to deal with memory corruption issues until 4-phase transactions are complete </dd>
</dl>
<p><a class="anchor" id="_todo000071"></a> </p>
<dl>
<dt>Member <a class="el" href="classSimpleTimingPort.html#af2f658f5d77eaafec20768ea3f7d8580">SimpleTimingPort::pendingDelete</a>  </dt>
<dd>this is a temporary workaround until the 4-phase code is committed. upstream caches need this packet until true is returned, so hold it for deletion until a subsequent call </dd>
</dl>
<p><a class="anchor" id="_todo000069"></a> </p>
<dl>
<dt>Member <a class="el" href="classSimpleTimingPort.html#a5ebd4fad99faad82d42fec8c347fe8ca">SimpleTimingPort::recvTimingReq</a> (PacketPtr pkt) </dt>
<dd><p class="startdd">temporary hack to deal with memory corruption issue until 4-phase transactions are complete. Remove me later </p>
<p class="enddd">nominally we should just delete the packet here. Until 4-phase stuff we can't because the sending cache is still relying on it </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000052"></a> </p>
<dl>
<dt>Member <a class="el" href="classSinic_1_1Base.html#aac9f3323f719a5d82640288264794907">Sinic::Base::cpuIntrPost</a> (Tick when) </dt>
<dd>this warning should be removed and the intrTick code should be fixed. </dd>
</dl>
<p><a class="anchor" id="_todo000053"></a> </p>
<dl>
<dt>Member <a class="el" href="classSinic_1_1Device.html#a3c0694b7d39175c4c4604601e4d6c87d">Sinic::Device::rxKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000054"></a> </p>
<dl>
<dt>Member <a class="el" href="classSinic_1_1Device.html#a328928a054fb0ac8251fbaf6187e8dd6">Sinic::Device::txKick</a> () </dt>
<dd>do we want to schedule a future kick? </dd>
</dl>
<p><a class="anchor" id="_todo000035"></a> </p>
<dl>
<dt>Class <a class="el" href="classSystemCounter.html">SystemCounter</a>  </dt>
<dd>: implement memory-mapped controls </dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>Member <a class="el" href="classTrace_1_1InstPBTrace.html#a76cdf11356afb176da9e161f2a919630">Trace::InstPBTrace::traceInst</a> (<a class="el" href="classThreadContext.html" title="ThreadContext is the external interface to all thread state for anything outside...">ThreadContext</a> *tc, StaticInstPtr si, TheISA::PCState pc) </dt>
<dd>if we are running multi-threaded I assume we'd need a lock here </dd>
</dl>
<p><a class="anchor" id="_todo000034"></a> </p>
<dl>
<dt>Member <a class="el" href="classTsunamiPChip.html#af1cba90e645d941c12df162545fd45df">TsunamiPChip::translatePciToDma</a> (Addr busAddr) </dt>
<dd><p class="startdd">Andrew says this needs to be fixed. What's wrong with it? </p>
<p class="enddd">This currently is faked by just doing a direct read from memory, however, to be realistic, this needs to actually do a bus transaction. The process is explained in the tsunami documentation on page 10-12 and basically munges the address to look up a PTE from a table in memory and then uses that mapping to create an address for the SG page </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>Class <a class="el" href="classUnifiedFreeList.html">UnifiedFreeList</a>  </dt>
<dd>: Give a better name to the base FP dependency. </dd>
</dl>
<p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>Member <a class="el" href="classVncServer.html#a5f88128dc2185a16b86d7e5476cab793">VncServer::sendFrameBufferUpdate</a> () </dt>
<dd>this doesn't do anything smart and just sends the entire image </dd>
</dl>
<p><a class="anchor" id="_todo000005"></a> </p>
<dl>
<dt>Member <a class="el" href="namespaceX86ISA.html#ae6679b41ceb610a77f04670463cbe737">X86ISA::convX87XTagsToTags</a> (uint8_t ftwx) </dt>
<dd><p class="startdd">Reconstruct the correct state of stack positions instead of just valid/invalid.</p>
<p class="enddd"></p>
</dd>
</dl>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Mon Dec 7 02:33:15 2015 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.6.1</small></address>

</body>
</html>
