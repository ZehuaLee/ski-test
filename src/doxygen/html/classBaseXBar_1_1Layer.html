<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gem5: BaseXBar::Layer&lt; SrcType, DstType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="classBaseXBar.html">BaseXBar</a>::<a class="el" href="classBaseXBar_1_1Layer.html">Layer</a>
  </div>
</div>
<div class="contents">
<h1>BaseXBar::Layer&lt; SrcType, DstType &gt; Class Template Reference</h1><!-- doxytag: class="BaseXBar::Layer" --><!-- doxytag: inherits="Drainable" -->
<p>A layer is an internal crossbar arbitration point with its own flow control.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xbar_8hh_source.html">xbar.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BaseXBar::Layer&lt; SrcType, DstType &gt;:</div>
<div class="dynsection">
 <div class="center">
  <img src="classBaseXBar_1_1Layer.gif" usemap="#BaseXBar::Layer&lt; SrcType, DstType &gt;_map" alt=""/>
  <map id="BaseXBar::Layer&lt; SrcType, DstType &gt;_map" name="BaseXBar::Layer&lt; SrcType, DstType &gt;_map">
<area href="classDrainable.html" alt="Drainable" shape="rect" coords="0,0,235,24"/>
</map>
 </div>
</div>

<p><a href="classBaseXBar_1_1Layer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a428be70018298eaa415485040d397f11">Layer</a> (DstType &amp;_port, <a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;_xbar, const std::string &amp;<a class="el" href="classBaseXBar_1_1Layer.html#a9a8b8f3c32cb2bfe3c4cd109a021382b">_name</a>)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a layer and give it a name.  <a href="#a428be70018298eaa415485040d397f11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#afab7dfff672af6ab477c8da80b60742b">drain</a> (<a class="el" href="classDrainManager.html">DrainManager</a> *dm)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Drain according to the normal semantics, so that the crossbar can tell the layer to drain, and pass an event to signal back when drained.  <a href="#afab7dfff672af6ab477c8da80b60742b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a73f4becfcbbbe4ae8b5fbf0e02d4e19f">name</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the crossbar layer's name.  <a href="#a73f4becfcbbbe4ae8b5fbf0e02d4e19f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a4d5b4d82d1ea6bf19fefcc526eb886e3">tryTiming</a> (SrcType *src_port)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determine if the layer accepts a packet from a specific port.  <a href="#a4d5b4d82d1ea6bf19fefcc526eb886e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a9f80cb4abd4bf038af15c05081d02d7d">succeededTiming</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> busy_time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deal with a destination port accepting a packet by potentially removing the source port from the retry list (if retrying) and occupying the layer accordingly.  <a href="#a9f80cb4abd4bf038af15c05081d02d7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a93a826f1e373e29eb3bfeae7ef3a8fa9">failedTiming</a> (SrcType *src_port, <a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> busy_time)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deal with a destination port not accepting a packet by potentially adding the source port to the retry list (if not already at the front) and occupying the layer accordingly.  <a href="#a93a826f1e373e29eb3bfeae7ef3a8fa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a93b3f67580238f9ca8b9d54e62036a46">occupyLayer</a> (<a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a> until)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Occupy the layer until until.  <a href="#a93b3f67580238f9ca8b9d54e62036a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a851f58de95a95afc51f864b32d9ff880">retryWaiting</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a retry to the port at the head of waitingForLayer.  <a href="#a851f58de95a95afc51f864b32d9ff880"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a40aa1d99311685b1bcc9e2c9784730c3">recvRetry</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle a retry from a neighbouring module.  <a href="#a40aa1d99311685b1bcc9e2c9784730c3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aac8fa3d103a6d609c693da33b21b5955">regStats</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register stats for the layer.  <a href="#aac8fa3d103a6d609c693da33b21b5955"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a170527789700e5ba3b60c57274c1e834">sendRetry</a> (SrcType *retry_port)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sending the actual retry, in a manner specific to the individual layers.  <a href="#a170527789700e5ba3b60c57274c1e834"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a> { <a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a477d4815cfed34a8bdead62bead99bf3">IDLE</a>, 
<a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a57716336066224386ba0ccd513c1082c">BUSY</a>, 
<a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853a511ea8beebae31279c7c7d82e2b16144">RETRY</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>We declare an enum to track the state of the layer. </p>
 <a href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a83153991c1984dd752e6c1d5b935c1f8">releaseLayer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Release the layer after being occupied and return to an idle state where we proceed to send a retry to any potential waiting port, or drain if asked to do so.  <a href="#a83153991c1984dd752e6c1d5b935c1f8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DstType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a4e62a15e2b97470f15934f764869fe4d">port</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destination port this layer converges at.  <a href="#a4e62a15e2b97470f15934f764869fe4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aeaf39e091d7dd8430c5c18838c96bf89">xbar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The crossbar this layer is a part of.  <a href="#aeaf39e091d7dd8430c5c18838c96bf89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a9a8b8f3c32cb2bfe3c4cd109a021382b">_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A name for this layer.  <a href="#a9a8b8f3c32cb2bfe3c4cd109a021382b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ac2c7640848b98813aa4f0eff6d71c542">state</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">track the state of the layer  <a href="#ac2c7640848b98813aa4f0eff6d71c542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aa11504e274bf7ac47fafc8dc10249072">drainManager</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">manager to signal when drained  <a href="#aa11504e274bf7ac47fafc8dc10249072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt; SrcType * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#ac18099d5e0514428ef7d4fe59b80ec0b">waitingForLayer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A deque of ports that retry should be called on because the original send was delayed due to a busy layer.  <a href="#ac18099d5e0514428ef7d4fe59b80ec0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SrcType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#afee92c98b7237b3f836b2b908cccedfc">waitingForPeer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Track who is waiting for the retry when receiving it from a peer.  <a href="#afee92c98b7237b3f836b2b908cccedfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt; <a class="el" href="classBaseXBar_1_1Layer.html">Layer</a>,&amp;Layer::releaseLayer &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aa022ec21d2c1f2c721e9bf52f83bd218">releaseEvent</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">event used to schedule a release of the layer  <a href="#aa022ec21d2c1f2c721e9bf52f83bd218"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#aab6ae1b92ca750758b4fa8165b6102b9">occupancy</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceStats.html">Stats</a> for occupancy and utilization.  <a href="#aab6ae1b92ca750758b4fa8165b6102b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classStats_1_1Formula.html">Stats::Formula</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBaseXBar_1_1Layer.html#a0909c1252acbfed0b398bb60e803d434">utilization</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;typename SrcType, typename DstType&gt;<br/>
 class BaseXBar::Layer&lt; SrcType, DstType &gt;</h3>

<p>A layer is an internal crossbar arbitration point with its own flow control. </p>
<p>Each layer is a converging multiplexer tree. By instantiating one layer per destination port (and per packet type, i.e. request, response, snoop request and snoop response), we model full crossbar structures like AXI, ACE, PCIe, etc.</p>
<p>The template parameter, PortClass, indicates the destination port type for the layer. The retry list holds either master ports or slave ports, depending on the direction of the layer. Thus, a request layer has a retry list containing slave ports, whereas a response layer holds master ports. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00092">92</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad8d693fc2d8f687b84ae40257f6ad853"></a><!-- doxytag: member="BaseXBar::Layer::State" ref="ad8d693fc2d8f687b84ae40257f6ad853" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">BaseXBar::Layer::State</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We declare an enum to track the state of the layer. </p>
<p>The starting point is an idle state where the layer is waiting for a packet to arrive. Upon arrival, the layer transitions to the busy state, where it remains either until the packet transfer is done, or the header time is spent. Once the layer leaves the busy state, it can either go back to idle, if no packets have arrived while it was busy, or the layer goes on to retry the first port in waitingForLayer. A similar transition takes place from idle to retry if the layer receives a retry from one of its connected ports. The retry state lasts until the port in questions calls sendTiming and returns control to the layer, or goes to a busy state if the port does not immediately react to the retry by calling sendTiming. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad8d693fc2d8f687b84ae40257f6ad853a477d4815cfed34a8bdead62bead99bf3"></a><!-- doxytag: member="IDLE" ref="ad8d693fc2d8f687b84ae40257f6ad853a477d4815cfed34a8bdead62bead99bf3" args="" -->IDLE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8d693fc2d8f687b84ae40257f6ad853a57716336066224386ba0ccd513c1082c"></a><!-- doxytag: member="BUSY" ref="ad8d693fc2d8f687b84ae40257f6ad853a57716336066224386ba0ccd513c1082c" args="" -->BUSY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad8d693fc2d8f687b84ae40257f6ad853a511ea8beebae31279c7c7d82e2b16144"></a><!-- doxytag: member="RETRY" ref="ad8d693fc2d8f687b84ae40257f6ad853a511ea8beebae31279c7c7d82e2b16144" args="" -->RETRY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Reimplemented from <a class="el" href="classDrainable.html#a6173416423af6af1bfe17262be40b5ff">Drainable</a>.</p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00214">214</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a428be70018298eaa415485040d397f11"></a><!-- doxytag: member="BaseXBar::Layer::Layer" ref="a428be70018298eaa415485040d397f11" args="(DstType &amp;_port, BaseXBar &amp;_xbar, const std::string &amp;_name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html">Layer</a> </td>
          <td>(</td>
          <td class="paramtype">DstType &amp;&nbsp;</td>
          <td class="paramname"> <em>_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBaseXBar.html">BaseXBar</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>_xbar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a layer and give it a name. </p>
<p>The layer uses the crossbar an event manager.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>_port</em>&nbsp;</td><td>destination port the layer converges at </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_xbar</em>&nbsp;</td><td>the crossbar this layer belongs to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_name</em>&nbsp;</td><td>the layer's name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00146">146</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="afab7dfff672af6ab477c8da80b60742b"></a><!-- doxytag: member="BaseXBar::Layer::drain" ref="afab7dfff672af6ab477c8da80b60742b" args="(DrainManager *dm)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::drain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDrainManager.html">DrainManager</a> *&nbsp;</td>
          <td class="paramname"> <em>dm</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drain according to the normal semantics, so that the crossbar can tell the layer to drain, and pass an event to signal back when drained. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>de</em>&nbsp;</td><td>drain event to call once drained</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if busy or waiting to retry, or 0 if idle </dd></dl>

<p>Implements <a class="el" href="classDrainable.html#a5925c6c8b75c58fc9a50fdd9094bee22">Drainable</a>.</p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00591">591</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="xbar_8hh_source.html#l00220">BaseXBar::Layer&lt; SrcType, DstType &gt;::drainManager</a>, <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::IDLE</a>, and <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>.</p>

</div>
</div>
<a class="anchor" id="a93a826f1e373e29eb3bfeae7ef3a8fa9"></a><!-- doxytag: member="BaseXBar::Layer::failedTiming" ref="a93a826f1e373e29eb3bfeae7ef3a8fa9" args="(SrcType *src_port, Tick busy_time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::failedTiming </td>
          <td>(</td>
          <td class="paramtype">SrcType *&nbsp;</td>
          <td class="paramname"> <em>src_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>busy_time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deal with a destination port not accepting a packet by potentially adding the source port to the retry list (if not already at the front) and occupying the layer accordingly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>src_port</em>&nbsp;</td><td>Source port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>busy_time</em>&nbsp;</td><td><a class="el" href="classTime.html">Time</a> to spend as a result of a failed send </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00218">218</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, and <a class="el" href="xbar_8hh_source.html#l00232">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForPeer</a>.</p>

</div>
</div>
<a class="anchor" id="a73f4becfcbbbe4ae8b5fbf0e02d4e19f"></a><!-- doxytag: member="BaseXBar::Layer::name" ref="a73f4becfcbbbe4ae8b5fbf0e02d4e19f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the crossbar layer's name. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00121">121</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00606">BaseXBar::Layer&lt; SrcType, DstType &gt;::regStats()</a>.</p>

</div>
</div>
<a class="anchor" id="a93b3f67580238f9ca8b9d54e62036a46"></a><!-- doxytag: member="BaseXBar::Layer::occupyLayer" ref="a93b3f67580238f9ca8b9d54e62036a46" args="(Tick until)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::occupyLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>until</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Occupy the layer until until. </p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00154">154</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="core_8hh_source.html#l00047">curTick()</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="xbar_8hh_source.html#l00249">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupancy</a>, <a class="el" href="xbar_8hh_source.html#l00242">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseEvent</a>, <a class="el" href="eventq_8hh_source.html#l00678">EventManager::schedule()</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, and <a class="el" href="xbar_8hh_source.html#l00193">BaseXBar::Layer&lt; SrcType, DstType &gt;::xbar</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00218">BaseXBar::Layer&lt; SrcType, DstType &gt;::failedTiming()</a>, <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>, and <a class="el" href="xbar_8cc_source.html#l00206">BaseXBar::Layer&lt; SrcType, DstType &gt;::succeededTiming()</a>.</p>

</div>
</div>
<a class="anchor" id="a40aa1d99311685b1bcc9e2c9784730c3"></a><!-- doxytag: member="BaseXBar::Layer::recvRetry" ref="a40aa1d99311685b1bcc9e2c9784730c3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::recvRetry </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle a retry from a neighbouring module. </p>
<p>This wraps retryWaiting by verifying that there are ports waiting before calling retryWaiting. </p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00301">301</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::IDLE</a>, <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, <a class="el" href="xbar_8hh_source.html#l00226">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForLayer</a>, and <a class="el" href="xbar_8hh_source.html#l00232">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForPeer</a>.</p>

</div>
</div>
<a class="anchor" id="aac8fa3d103a6d609c693da33b21b5955"></a><!-- doxytag: member="BaseXBar::Layer::regStats" ref="aac8fa3d103a6d609c693da33b21b5955" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::regStats </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register stats for the layer. </p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00606">606</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00121">BaseXBar::Layer&lt; SrcType, DstType &gt;::name()</a>, <a class="el" href="statistics_8hh_source.html#l00250">Stats::DataWrap&lt; Derived, InfoProxyType &gt;::name()</a>, <a class="el" href="info_8hh_source.html#l00057">Stats::nozero</a>, <a class="el" href="xbar_8hh_source.html#l00249">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupancy</a>, <a class="el" href="stat__control_8cc_source.html#l00064">simTicks</a>, and <a class="el" href="xbar_8hh_source.html#l00250">BaseXBar::Layer&lt; SrcType, DstType &gt;::utilization</a>.</p>

</div>
</div>
<a class="anchor" id="a83153991c1984dd752e6c1d5b935c1f8"></a><!-- doxytag: member="BaseXBar::Layer::releaseLayer" ref="a83153991c1984dd752e6c1d5b935c1f8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::releaseLayer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release the layer after being occupied and return to an idle state where we proceed to send a retry to any potential waiting port, or drain if asked to do so. </p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00240">240</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="base_2trace_8hh_source.html#l00211">DPRINTF</a>, <a class="el" href="xbar_8hh_source.html#l00220">BaseXBar::Layer&lt; SrcType, DstType &gt;::drainManager</a>, <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::IDLE</a>, <a class="el" href="xbar_8hh_source.html#l00242">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseEvent</a>, <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>, <a class="el" href="eventq_8hh_source.html#l00330">Event::scheduled()</a>, <a class="el" href="drain_8hh_source.html#l00086">DrainManager::signalDrainDone()</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, <a class="el" href="xbar_8hh_source.html#l00226">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForLayer</a>, and <a class="el" href="xbar_8hh_source.html#l00232">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForPeer</a>.</p>

</div>
</div>
<a class="anchor" id="a851f58de95a95afc51f864b32d9ff880"></a><!-- doxytag: member="BaseXBar::Layer::retryWaiting" ref="a851f58de95a95afc51f864b32d9ff880" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::retryWaiting </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a retry to the port at the head of waitingForLayer. </p>
<p>The caller must ensure that the list is not empty. </p>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00266">266</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="clocked__object_8hh_source.html#l00171">ClockedObject::clockEdge()</a>, <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::IDLE</a>, <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::RETRY</a>, <a class="el" href="classBaseXBar_1_1Layer.html#a170527789700e5ba3b60c57274c1e834">BaseXBar::Layer&lt; SrcType, DstType &gt;::sendRetry()</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, <a class="el" href="xbar_8hh_source.html#l00226">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForLayer</a>, and <a class="el" href="xbar_8hh_source.html#l00193">BaseXBar::Layer&lt; SrcType, DstType &gt;::xbar</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00301">BaseXBar::Layer&lt; SrcType, DstType &gt;::recvRetry()</a>, and <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="a170527789700e5ba3b60c57274c1e834"></a><!-- doxytag: member="BaseXBar::Layer::sendRetry" ref="a170527789700e5ba3b60c57274c1e834" args="(SrcType *retry_port)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::sendRetry </td>
          <td>(</td>
          <td class="paramtype">SrcType *&nbsp;</td>
          <td class="paramname"> <em>retry_port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sending the actual retry, in a manner specific to the individual layers. </p>
<p>Note that for a <a class="el" href="classMasterPort.html" title="A MasterPort is a specialisation of a BaseMasterPort, which implements the default...">MasterPort</a>, there is both a RequestLayer and a SnoopResponseLayer using the same port, but using different functions for the flow control. </p>

<p>Implemented in <a class="el" href="classBaseXBar_1_1ReqLayer.html#ac5c1989b3b614fe597c5bbc05fa8bc2d">BaseXBar::ReqLayer</a>, <a class="el" href="classBaseXBar_1_1RespLayer.html#a33061315cf04958a213e290ec32652d8">BaseXBar::RespLayer</a>, and <a class="el" href="classBaseXBar_1_1SnoopRespLayer.html#a6881b720a0dbaac0cf4d0254de31dcd2">BaseXBar::SnoopRespLayer</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f80cb4abd4bf038af15c05081d02d7d"></a><!-- doxytag: member="BaseXBar::Layer::succeededTiming" ref="a9f80cb4abd4bf038af15c05081d02d7d" args="(Tick busy_time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType , typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::succeededTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="base_2types_8hh.html#a5c8ed81b7d238c9083e1037ba6d61643">Tick</a>&nbsp;</td>
          <td class="paramname"> <em>busy_time</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deal with a destination port accepting a packet by potentially removing the source port from the retry list (if retrying) and occupying the layer accordingly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>busy_time</em>&nbsp;</td><td><a class="el" href="classTime.html">Time</a> to spend as a result of a successful send </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00206">206</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, and <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>.</p>

</div>
</div>
<a class="anchor" id="a4d5b4d82d1ea6bf19fefcc526eb886e3"></a><!-- doxytag: member="BaseXBar::Layer::tryTiming" ref="a4d5b4d82d1ea6bf19fefcc526eb886e3" args="(SrcType *src_port)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::tryTiming </td>
          <td>(</td>
          <td class="paramtype">SrcType *&nbsp;</td>
          <td class="paramname"> <em>src_port</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine if the layer accepts a packet from a specific port. </p>
<p>If not, the port in question is also added to the retry list. In either case the state of the layer is updated accordingly.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Source port presenting the packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the layer accepts the packet </dd></dl>

<p>Definition at line <a class="el" href="xbar_8cc_source.html#l00175">175</a> of file <a class="el" href="xbar_8cc_source.html">xbar.cc</a>.</p>

<p>References <a class="el" href="xbar_8hh_source.html#l00214">BaseXBar::Layer&lt; SrcType, DstType &gt;::BUSY</a>, <a class="el" href="xbar_8hh_source.html#l00217">BaseXBar::Layer&lt; SrcType, DstType &gt;::state</a>, <a class="el" href="xbar_8hh_source.html#l00226">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForLayer</a>, and <a class="el" href="xbar_8hh_source.html#l00232">BaseXBar::Layer&lt; SrcType, DstType &gt;::waitingForPeer</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a9a8b8f3c32cb2bfe3c4cd109a021382b"></a><!-- doxytag: member="BaseXBar::Layer::_name" ref="a9a8b8f3c32cb2bfe3c4cd109a021382b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#a9a8b8f3c32cb2bfe3c4cd109a021382b">_name</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A name for this layer. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00196">196</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a class="anchor" id="aa11504e274bf7ac47fafc8dc10249072"></a><!-- doxytag: member="BaseXBar::Layer::drainManager" ref="aa11504e274bf7ac47fafc8dc10249072" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDrainManager.html">DrainManager</a>* <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#aa11504e274bf7ac47fafc8dc10249072">drainManager</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>manager to signal when drained </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00220">220</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00591">BaseXBar::Layer&lt; SrcType, DstType &gt;::drain()</a>, and <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="aab6ae1b92ca750758b4fa8165b6102b9"></a><!-- doxytag: member="BaseXBar::Layer::occupancy" ref="aab6ae1b92ca750758b4fa8165b6102b9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Scalar.html">Stats::Scalar</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#aab6ae1b92ca750758b4fa8165b6102b9">occupancy</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><a class="el" href="namespaceStats.html">Stats</a> for occupancy and utilization. </p>
<p>These stats capture the time the layer spends in the busy state and are thus only relevant when the memory system is in timing mode. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00249">249</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, and <a class="el" href="xbar_8cc_source.html#l00606">BaseXBar::Layer&lt; SrcType, DstType &gt;::regStats()</a>.</p>

</div>
</div>
<a class="anchor" id="a4e62a15e2b97470f15934f764869fe4d"></a><!-- doxytag: member="BaseXBar::Layer::port" ref="a4e62a15e2b97470f15934f764869fe4d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DstType&amp; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#a4e62a15e2b97470f15934f764869fe4d">port</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destination port this layer converges at. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00190">190</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

</div>
</div>
<a class="anchor" id="aa022ec21d2c1f2c721e9bf52f83bd218"></a><!-- doxytag: member="BaseXBar::Layer::releaseEvent" ref="aa022ec21d2c1f2c721e9bf52f83bd218" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEventWrapper.html">EventWrapper</a>&lt;<a class="el" href="classBaseXBar_1_1Layer.html">Layer</a>, &amp;Layer::releaseLayer&gt; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#aa022ec21d2c1f2c721e9bf52f83bd218">releaseEvent</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>event used to schedule a release of the layer </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00242">242</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, and <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c7640848b98813aa4f0eff6d71c542"></a><!-- doxytag: member="BaseXBar::Layer::state" ref="ac2c7640848b98813aa4f0eff6d71c542" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar_1_1Layer.html#ad8d693fc2d8f687b84ae40257f6ad853">State</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#ac2c7640848b98813aa4f0eff6d71c542">state</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>track the state of the layer </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00217">217</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00591">BaseXBar::Layer&lt; SrcType, DstType &gt;::drain()</a>, <a class="el" href="xbar_8cc_source.html#l00218">BaseXBar::Layer&lt; SrcType, DstType &gt;::failedTiming()</a>, <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, <a class="el" href="xbar_8cc_source.html#l00301">BaseXBar::Layer&lt; SrcType, DstType &gt;::recvRetry()</a>, <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>, <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>, <a class="el" href="xbar_8cc_source.html#l00206">BaseXBar::Layer&lt; SrcType, DstType &gt;::succeededTiming()</a>, and <a class="el" href="xbar_8cc_source.html#l00175">BaseXBar::Layer&lt; SrcType, DstType &gt;::tryTiming()</a>.</p>

</div>
</div>
<a class="anchor" id="a0909c1252acbfed0b398bb60e803d434"></a><!-- doxytag: member="BaseXBar::Layer::utilization" ref="a0909c1252acbfed0b398bb60e803d434" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classStats_1_1Formula.html">Stats::Formula</a> <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#a0909c1252acbfed0b398bb60e803d434">utilization</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00250">250</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00606">BaseXBar::Layer&lt; SrcType, DstType &gt;::regStats()</a>.</p>

</div>
</div>
<a class="anchor" id="ac18099d5e0514428ef7d4fe59b80ec0b"></a><!-- doxytag: member="BaseXBar::Layer::waitingForLayer" ref="ac18099d5e0514428ef7d4fe59b80ec0b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classstd_1_1deque.html">std::deque</a>&lt;SrcType*&gt; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#ac18099d5e0514428ef7d4fe59b80ec0b">waitingForLayer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A deque of ports that retry should be called on because the original send was delayed due to a busy layer. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00226">226</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00301">BaseXBar::Layer&lt; SrcType, DstType &gt;::recvRetry()</a>, <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>, <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>, and <a class="el" href="xbar_8cc_source.html#l00175">BaseXBar::Layer&lt; SrcType, DstType &gt;::tryTiming()</a>.</p>

</div>
</div>
<a class="anchor" id="afee92c98b7237b3f836b2b908cccedfc"></a><!-- doxytag: member="BaseXBar::Layer::waitingForPeer" ref="afee92c98b7237b3f836b2b908cccedfc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SrcType* <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#afee92c98b7237b3f836b2b908cccedfc">waitingForPeer</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Track who is waiting for the retry when receiving it from a peer. </p>
<p>If no port is waiting NULL is stored. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00232">232</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8cc_source.html#l00218">BaseXBar::Layer&lt; SrcType, DstType &gt;::failedTiming()</a>, <a class="el" href="xbar_8cc_source.html#l00301">BaseXBar::Layer&lt; SrcType, DstType &gt;::recvRetry()</a>, <a class="el" href="xbar_8cc_source.html#l00240">BaseXBar::Layer&lt; SrcType, DstType &gt;::releaseLayer()</a>, and <a class="el" href="xbar_8cc_source.html#l00175">BaseXBar::Layer&lt; SrcType, DstType &gt;::tryTiming()</a>.</p>

</div>
</div>
<a class="anchor" id="aeaf39e091d7dd8430c5c18838c96bf89"></a><!-- doxytag: member="BaseXBar::Layer::xbar" ref="aeaf39e091d7dd8430c5c18838c96bf89" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SrcType, typename DstType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBaseXBar.html">BaseXBar</a>&amp; <a class="el" href="classBaseXBar_1_1Layer.html">BaseXBar::Layer</a>&lt; SrcType, DstType &gt;::<a class="el" href="classBaseXBar_1_1Layer.html#aeaf39e091d7dd8430c5c18838c96bf89">xbar</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The crossbar this layer is a part of. </p>

<p>Definition at line <a class="el" href="xbar_8hh_source.html#l00193">193</a> of file <a class="el" href="xbar_8hh_source.html">xbar.hh</a>.</p>

<p>Referenced by <a class="el" href="xbar_8hh_source.html#l00121">BaseXBar::Layer&lt; MasterPort, SlavePort &gt;::name()</a>, <a class="el" href="xbar_8cc_source.html#l00154">BaseXBar::Layer&lt; SrcType, DstType &gt;::occupyLayer()</a>, and <a class="el" href="xbar_8cc_source.html#l00266">BaseXBar::Layer&lt; SrcType, DstType &gt;::retryWaiting()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>mem/<a class="el" href="xbar_8hh_source.html">xbar.hh</a></li>
<li>mem/<a class="el" href="xbar_8cc_source.html">xbar.cc</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"><address style="align: right;"><small>
Generated on Mon Dec 7 02:33:17 2015 for gem5 by <a href="http://www.doxygen.org/index.html"> doxygen</a> 1.6.1</small></address>

</body>
</html>
